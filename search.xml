<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HomeKit开发环境搭建-ESP8266</title>
    <url>/homekit-kai-fa/esp8266-env/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文使用的ESP8266芯片的开发商乐鑫科技在github上发布过自己的HomeKit SDK，支持ESP32、ESP32-S2和ESP8266 SoC，我们在这里将搭建ESP8266的环境。</p>
<h2 id="1-下载HomeKit-SDK"><a href="#1-下载HomeKit-SDK" class="headerlink" title="1. 下载HomeKit SDK"></a>1. 下载HomeKit SDK</h2><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk">git clone --recursive https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/espressif/</span>esp-homekit-sdk.git HomeKitDev<br>cd HomeKitDev<br>export HOMEKIT_PATH=<span class="hljs-variable">$PWD</span><br></code></pre></td></tr></tbody></table></figure>

<h2 id="2-下载编译工具链"><a href="#2-下载编译工具链" class="headerlink" title="2. 下载编译工具链"></a>2. 下载编译工具链</h2><figure class="highlight apache"><table><tbody><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">curl</span> -O https://dl.espressif.com/dl/xtensa-lx<span class="hljs-number">106</span>-elf-gcc<span class="hljs-number">8</span>_<span class="hljs-number">4</span>_<span class="hljs-number">0</span>-esp-<span class="hljs-number">2020</span>r<span class="hljs-number">3</span>-macos.tar.gz<br><span class="hljs-attribute">tar</span> -xzf xtensa-lx<span class="hljs-number">106</span>-elf-gcc<span class="hljs-number">8</span>_<span class="hljs-number">4</span>_<span class="hljs-number">0</span>-esp-<span class="hljs-number">2020</span>r<span class="hljs-number">3</span>-macos.tar.gz<br><span class="hljs-attribute">rm</span> xtensa-lx<span class="hljs-number">106</span>-elf-gcc<span class="hljs-number">8</span>_<span class="hljs-number">4</span>_<span class="hljs-number">0</span>-esp-<span class="hljs-number">2020</span>r<span class="hljs-number">3</span>-macos.tar.gz<br><span class="hljs-attribute">cd</span> xtensa-lx<span class="hljs-number">106</span>-elf<br><span class="hljs-attribute">export</span> PATH=$PWD/bin:$PATH<br></code></pre></td></tr></tbody></table></figure>

<p><a href="https://docs.espressif.com/projects/esp8266-rtos-sdk/en/latest/get-started/windows-setup.html">Windows</a>版本和<a href="https://docs.espressif.com/projects/esp8266-rtos-sdk/en/latest/get-started/linux-setup.html">Linux</a>版本的工具链可点击相应链接查看安装方法。</p>
<h2 id="3-下载RTOS-SDK"><a href="#3-下载RTOS-SDK" class="headerlink" title="3. 下载RTOS SDK"></a>3. 下载RTOS SDK</h2><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk">git clone --recursive https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/espressif/</span>ESP8266_RTOS_SDK.git<br>cd ESP8266_RTOS_SDK<br>export IDF_PATH=<span class="hljs-variable">$PWD</span><br>python -m pip install -r <span class="hljs-variable">$IDF_PATH</span>/requirements.txt<br></code></pre></td></tr></tbody></table></figure>

<p>这里需要注意，如果要用python3，需要在Anaconda这种虚拟环境里操作，否则只能使用python2。</p>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>如果以上配置均没有错误，执行以下命令应当可以看见配置页面：</p>
<figure class="highlight dsconfig"><table><tbody><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">cd </span><span class="hljs-string">examples/</span><span class="hljs-built_in">get-started/hello_world/</span><br><span class="hljs-built_in">make</span> <span class="hljs-string">menuconfig</span><br></code></pre></td></tr></tbody></table></figure>
<img src="https://docs.espressif.com/projects/esp8266-rtos-sdk/en/latest/_images/project-configuration.png" title="配置页面">

<p>在<code>Serial flasher config</code>中选择<code>Default serial port</code>，设置好串口，保存退出即可。在windows系统中，串口号以<code>COM</code>开头，而MacOS和Linux系统中则以<code>/dev/cu.</code>或<code>/dev/tty.</code>开头。例如在我的系统中串口为<code>/dev/cu.usbserial-14330</code>。</p>
<p>此外，还可以通过环境变量设置默认串口，以我的系统为例：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ESPPORT</span>=/dev/cu.usbserial-14330<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ESPBAUD</span>=115200<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">MONITORBAUD</span>=115200<br></code></pre></td></tr></tbody></table></figure>

<p>编译固件并下载到Soc，只需要输入一行命令：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make flash</span><br></code></pre></td></tr></tbody></table></figure>

<p>打开串口监视器，可以输入：</p>
<figure class="highlight crmsh"><table><tbody><tr><td class="code"><pre><code class="hljs crmsh">make <span class="hljs-literal">monitor</span><br></code></pre></td></tr></tbody></table></figure>

<p>此外，还可以将上面两个命令合并为一行：</p>
<figure class="highlight crmsh"><table><tbody><tr><td class="code"><pre><code class="hljs crmsh">make flash <span class="hljs-literal">monitor</span><br></code></pre></td></tr></tbody></table></figure>

<p>至此，开发环境搭建完成。</p>
]]></content>
      <categories>
        <category>HomeKit开发</category>
      </categories>
  </entry>
  <entry>
    <title>PyMOL做出非氢键相互作用图</title>
    <url>/pymol-xi-lie-jiao-cheng/pymol-zuo-chu-fei-qing-jian-xiang-hu-zuo-yong-tu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上文中，我们尝试模仿绘制文献中的Figure 2a，所选文献为<a href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.5b01875"><em>J. Med. Chem.</em> 2016, 59, 4087−4102</a>，本文将尝试绘制Figure 2b，原图如下所示：</p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjo1t4vxk5j30zy0cmti4.jpg" title="Figure 2" width="75%" height="75%">

<p>本例中使用的PDB code: 3kwf</p>
<p>首先加载大分子： </p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">fetch</span> <span class="hljs-string">3kwf</span><br><span class="hljs-attr">bg</span> <span class="hljs-string">white</span><br></code></pre></td></tr></tbody></table></figure>
<p>接着创建新对象，在视图窗口右下角点击S按钮，顶部将显示蛋白质的序列，箭头所指位置为A链中的配体，其代号为B1Q。</p>
<img src="https://tvax2.sinaimg.cn/large/005Vgpymly1gjo1t50d1wj31i018owum.jpg" title="" width="65%" height="65%">

<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><code class="hljs angelscript">create lig, /<span class="hljs-number">3</span>kwf/E/A/<span class="hljs-number">1</span><br>create residues, (<span class="hljs-number">3</span>kwf <span class="hljs-keyword">and</span> (chain A <span class="hljs-keyword">in</span> resi <span class="hljs-number">630</span>+<span class="hljs-number">631</span>+<span class="hljs-number">659</span>+<span class="hljs-number">666</span>))<br></code></pre></td></tr></tbody></table></figure>
<p>单独显示我们的研究对象：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hide</span> <span class="hljs-string">everything</span><br><span class="hljs-attr">show</span> <span class="hljs-string">sticks, lig</span><br><span class="hljs-attr">show</span> <span class="hljs-string">sticks, residues</span><br><span class="hljs-attr">set_bond</span> <span class="hljs-string">stick_radius, 0.14, residues</span><br></code></pre></td></tr></tbody></table></figure>
<p>然后修改配体颜色，使其按元素显示。<br><img src="https://tva3.sinaimg.cn/large/005Vgpymly1gjo1t5fs01j31i018ogxz.jpg" title="" width="65%" height="65%"></p>
<p>按住control键，并用鼠标中键选择两个原子，然后松开control，使用鼠标左键选择氨基酸残基。完成后如图所示，残基被保存在<code>(sele)</code>中，原子被保存在<code>(pkset)</code>中。</p>
<img src="https://tva3.sinaimg.cn/large/005Vgpymly1gjo1t5shd4j31i018o167.jpg" title="" width="65%" height="65%">

<p>接着测量pkset与sele的距离，将距离小于4埃的显示出来：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><code class="hljs angelscript">distance nonbonded, pkset, sele, <span class="hljs-number">4</span>, <span class="hljs-number">0</span><br>color magenta, nonbonded<br></code></pre></td></tr></tbody></table></figure>

<p>然后在下图区域任意位置单击鼠标左键，将鼠标模式更改为Editing模式：<br><img src="https://tva3.sinaimg.cn/large/005Vgpymly1gjo1t65akwj30ca070jrj.jpg" title="" width="35%" height="35%"></p>
<p>按住control键，用鼠标左键将虚线上的距离移开。在上方菜单栏中点击<strong>Setting -&gt; Edit All</strong>，在<code>dash_radius</code>中输入0.07，按回车键确认。</p>
<img src="https://tva1.sinaimg.cn/large/005Vgpymly1gjo1t69keaj31i018o4ce.jpg" title="" width="65%" height="65%">
最后设定好视角，就可以输出了。
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><code class="hljs angelscript">set_view (\<br>     <span class="hljs-number">0.507353544</span>,    <span class="hljs-number">0.469124675</span>,    <span class="hljs-number">0.722847939</span>,\<br>     <span class="hljs-number">0.366444945</span>,   <span class="hljs-number">-0.876655817</span>,    <span class="hljs-number">0.311746955</span>,\<br>     <span class="hljs-number">0.779944181</span>,    <span class="hljs-number">0.106718525</span>,   <span class="hljs-number">-0.616688907</span>,\<br>     <span class="hljs-number">0.000415023</span>,    <span class="hljs-number">0.000164665</span>,  <span class="hljs-number">-94.643707275</span>,\<br>    <span class="hljs-number">20.837306976</span>,   <span class="hljs-number">37.008846283</span>,   <span class="hljs-number">57.467098236</span>,\<br>  <span class="hljs-number">-251.000549316</span>,  <span class="hljs-number">106.750518799</span>,  <span class="hljs-number">-20.000000000</span> )<br><br>draw <span class="hljs-number">1200</span>,<span class="hljs-number">800</span><br>png Figure2.png<br></code></pre></td></tr></tbody></table></figure>
<img src="https://tva1.sinaimg.cn/large/005Vgpymly1gjo1t6h13ij30xc0m8tcp.jpg" title="效果图" width="65%" height="65%">]]></content>
      <categories>
        <category>PyMOL系列教程</category>
      </categories>
  </entry>
  <entry>
    <title>PyMOL的基本操作</title>
    <url>/pymol-xi-lie-jiao-cheng/pymol-de-ji-ben-cao-zuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>PyMOL系列教程</category>
      </categories>
  </entry>
  <entry>
    <title>利用PyMOL做出大分子-配体相互作用图</title>
    <url>/pymol-xi-lie-jiao-cheng/li-yong-pymol-zuo-chu-da-fen-zi-pei-ti-xiang-hu-zuo-yong-tu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本文中，我们尝试模仿绘制文献中的Figure 2a，所选文献为<a href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.5b01875"><em>J. Med. Chem.</em> 2016, 59, 4087−4102</a>，原图如下所示：</p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjo1t4vxk5j30zy0cmti4.jpg" title="Figure 2" width="75%" height="75%">

<p>本例中使用的PDB code: 3oc0</p>
<p>首先加载大分子，使用<code>fetch</code>命令可直接从PDB数据库下载。为了方便操作，我们先把大分子和小分子分成两个对象保存： </p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fetch</span> <span class="hljs-number">3</span>oc<span class="hljs-number">0</span><br><span class="hljs-attribute">create</span> lig, /<span class="hljs-number">3</span>oc<span class="hljs-number">0</span>/G/A/<span class="hljs-number">900</span><br><span class="hljs-attribute">remove</span> /<span class="hljs-number">3</span>oc<span class="hljs-number">0</span>/G/A/<span class="hljs-number">900</span><br></code></pre></td></tr></tbody></table></figure>
<p>现在就可以看到两个对象，一个是除去配体的大分子，另一个是小分子：</p>
<img src="https://tva4.sinaimg.cn/large/005Vgpymly1gjo3bsef0jj31i018o4qp.jpg" title="" width="65%" height="65%">

<p>改变大分子和配体的显示样式：</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk">bg white			<span class="hljs-regexp">//</span>背景改为白色<br>as surface, <span class="hljs-number">3</span>oc0		<span class="hljs-regexp">//</span>显示大分子表面<br>color white, <span class="hljs-number">3</span>oc0		<span class="hljs-regexp">//</span>将颜色改为白色<br>set transparency, <span class="hljs-number">0.5</span>		<span class="hljs-regexp">//</span>设置透明度为<span class="hljs-number">50</span>%<br></code></pre></td></tr></tbody></table></figure>
<p>点击右侧控制台的<code>lig</code>对象的<code>C</code>项，选择<code>by element</code>，碳原子为cyan。</p>
<img src="https://tva4.sinaimg.cn/large/005Vgpymly1gjo3bsrp27j31i018ox39.jpg" title="" width="65%" height="65%">

<p>将我们需要的氨基酸残基复制到新对象中</p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create</span> residues, (<span class="hljs-number">3</span>oc<span class="hljs-number">0</span> in resi <span class="hljs-number">205</span>+<span class="hljs-number">206</span>+<span class="hljs-number">631</span>+<span class="hljs-number">656</span>+<span class="hljs-number">659</span>+<span class="hljs-number">662</span>+<span class="hljs-number">666</span>)<br></code></pre></td></tr></tbody></table></figure>
<p>此处<code>resi</code>意为<code>residue identifier</code>，即残基的编号。</p>
<p>改变残基显示样式</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">as</span> sticks, residues<br></code></pre></td></tr></tbody></table></figure>
<p>与lig相同，颜色选择by element，不过这次的碳原子选green。</p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjo3bt22qhj31i018okg9.jpg" title="" width="65%" height="65%">

<p>现在你可以看到，已经有文献里图片的内味了。</p>
<p>文献中的残基要比默认值更细，接下来修改粗细：</p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_bond</span> stick_radius, <span class="hljs-number">0</span>.<span class="hljs-number">1</span>, residues<br></code></pre></td></tr></tbody></table></figure>
<p>显示氢键：可以看到，文献中的图片只有一个氨基的氢键显示了出来，因此我们需要按住<code>control</code>键，再用鼠标中键单机该氮原子，现在右侧可以看到<code>(pk1)</code>对象，在其A项中选择<strong>find -&gt; polar contacts -&gt; to any atoms</strong></p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjo3bth17uj31i018oay2.jpg" title="" width="65%" height="65%">

<p>修改氢键样式：在上方菜单栏选择<strong>Setting -&gt; Edit All</strong>，输入<code>dash</code>，将<code>dash_color</code>修改为<code>red</code>，按回车键确认修改。</p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjo3btsc40j31g213mtxa.jpg" title="" width="65%" height="65%">

<p>最后将视图调整到合适的位置，就可以渲染输出了：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><code class="hljs angelscript">set_view (\<br>     <span class="hljs-number">0.596928358</span>,    <span class="hljs-number">0.462212354</span>,    <span class="hljs-number">0.655772686</span>,\<br>     <span class="hljs-number">0.506054461</span>,   <span class="hljs-number">-0.851173997</span>,    <span class="hljs-number">0.139291167</span>,\<br>     <span class="hljs-number">0.622557700</span>,    <span class="hljs-number">0.248710677</span>,   <span class="hljs-number">-0.742000937</span>,\<br>    <span class="hljs-number">-0.000598469</span>,    <span class="hljs-number">0.000388961</span>,  <span class="hljs-number">-60.677524567</span>,\<br>    <span class="hljs-number">54.435737610</span>,   <span class="hljs-number">52.480457306</span>,   <span class="hljs-number">29.589189529</span>,\<br>    <span class="hljs-number">57.677524567</span>,  <span class="hljs-number">549.791076660</span>,   <span class="hljs-number">20.000000000</span> )<br><br>ray <span class="hljs-number">1200</span>,<span class="hljs-number">800</span><br><br>png Figure1.png<br></code></pre></td></tr></tbody></table></figure>

<img src="https://tvax3.sinaimg.cn/large/005Vgpymly1gjo3btzy5wj30xc0m8akn.jpg" title="最终效果" width="50%" height="50%">]]></content>
      <categories>
        <category>PyMOL系列教程</category>
      </categories>
  </entry>
  <entry>
    <title>安装PyMOL</title>
    <url>/pymol-xi-lie-jiao-cheng/an-zhuang-pymol/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h1><p>PyMOL是由Warren Lyford DeLano编写的一个分子结构显示软件，由于生成的图片质量极高，受到了科研工作者的广泛好评；由PyMOL制作的图像屡次出现在Nature、Science等杂志的封面上，作者自己则称所有发表的蛋白质结构图像中，有1/4的是有PyMOL制作的。2010年，Schrödinger公司从DeLano Scientific LLC手中买下了PyMOL，继续发行PyMOL的商业版。与此同时，PyMOL还有一个由用户赞助的开源版本，相比商业版功能虽然少了一些，但是功能依旧强大。</p>
<p>PyMOL具有图形界面，在图形界面上具有命令行接口，可以输入指令来修改图形参数，同时还兼容少量bash的目录指令。</p>
<img src="https://tvax3.sinaimg.cn/large/005Vgpymly1gjv1m21qpbj315o0pj7wh.jpg" title="PyMOL的图形界面" width="70%" height="70%">


<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>PyMOL名字里虽然有一个Py，但是python代码只占其代码总量的10%，C/C++代码占了绝大多数。作为开源软件，它可以在全平台进行安装，我将依次介绍他们的安装方式。</p>
<ul>
<li><strong>Windows</strong></li>
</ul>
<p>在Windows下，如果你的电脑没有安装过python环境，首先需要安装python。完成之后直接运行Schrödinger的PyMOL安装包即可，Schrödinger的安装包应该会顺带安装一个python环境。虽然Windows下的安装包不是免费软件，但是你可以去申请一个education license使用，到期了还可以再申请。如果你想从源代码编译使用，那么可以尝试使用Cygwin。</p>
<ul>
<li><strong>Linux</strong></li>
</ul>
<p>虽然Schrödinger也提供了Linux下的安装包，但是在Linux下从源代码编译安装是十分方便的，因此我们来讲一下编译安装步骤。<br>（本文发布时源代码版本为2.4.0）</p>
<p>首先安装依赖，下面列出了各个系统的命令，需要使用root权限进行安装：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Debian/Ubuntu/Mint</span><br>apt-get install build-essential python-dev python-pmw libglew-dev \<br>  freeglut3-dev libpng-dev libfreetype6-dev libxml2-dev \<br>  libmsgpack-dev python-pyqt5.qtopengl libglm-dev<br><br><span class="hljs-comment"># CentOS</span><br>yum install gcc gcc-c++ kernel-devel python-devel tkinter python-pmw glew-devel \<br>  freeglut-devel libpng-devel freetype-devel libxml2-devel glm-devel<br><br><span class="hljs-comment"># Fedora</span><br>dnf install gcc gcc-c++ kernel-devel python-devel tkinter python-pmw glew-devel \<br>  freeglut-devel libpng-devel freetype-devel libxml2-devel glm-devel<br><br><span class="hljs-comment"># Gentoo</span><br>emerge -av dev-lang/python dev-python/pmw media-libs/glew \<br>  media-libs/freeglut media-libs/libpng media-libs/freetype media-libs/glm<br><br><span class="hljs-comment"># openSUSE</span><br>zypper install python-devel freeglut-devel gcc-c++ glew-devel libpng-devel python-pmw glm<br><br><span class="hljs-comment"># Sabayon</span><br>equo i -av dev-lang/python dev-python/pmw media-libs/glew \<br>  media-libs/freeglut media-libs/libpng media-libs/freetype<br></code></pre></td></tr></tbody></table></figure>

<p>以Ubuntu为例，在terminal中输入：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">sudo apt-get install build-essential python-dev python-pmw libglew-dev \<br>  freeglut3-dev libpng-dev libfreetype6-dev libxml2-dev \<br>  libmsgpack-dev python-pyqt5.qtopengl libglm-dev<br></code></pre></td></tr></tbody></table></figure>

<p>安装git，然后将源代码拷贝到本地：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">sudo apt-get install git<br>git <span class="hljs-built_in">clone</span> https://github.com/schrodinger/pymol-open-source.git<br></code></pre></td></tr></tbody></table></figure>

<p>完成后，cd进源代码目录，下载mmtf-cpp，然后运行setup.py：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> pymol-open-source<br>git <span class="hljs-built_in">clone</span> https://github.com/rcsb/mmtf-cpp.git<br>cp -r mmtf-cpp/include/* layer3/<br>python setup.py build install --home=<span class="hljs-variable">$HOME</span>/pymol<br></code></pre></td></tr></tbody></table></figure>

<p>等待编译完成以后，将<code>pymol/bin</code>添加到<code>PATH</code>:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">'export PATH=$PATH:$HOME/pymol/bin'</span> &gt;&gt; <span class="hljs-variable">$HOME</span>/.bashrc<br></code></pre></td></tr></tbody></table></figure>

<p>至此，程序就安装完成了，在一个新的terminal中输入<code>pymol</code>即可打开程序。</p>
<ul>
<li><strong>Mac OS X</strong></li>
</ul>
<p>在Mac上最简便的安装方式还是使用Schrödinger提供的dmg镜像，所以这里会着重介绍一下在mac上进行编译安装的步骤。本文使用的MacOS版本为10.13.3。<br>在安装PyMOL之前，你的电脑上需要安装有<a href="https://www.xquartz.org/">XQuartz</a>和<a href="https://brew.sh/">Homebrew</a>，当然如果你使用Fink或者MacPorts，只要能正确安装所有依赖，不使用Homebrew也是没问题的。目前pymol已经全面停止了对python2的支持，本文默认读者已经安装了python3.6以上的版本。Mac系统自带的gcc编译器的版本是4.2.1，而pymol要求最低4.7，因此需要先升级gcc，具体可以参考<a href="https://wangxin1248.github.io/life/2019/06/mac-update-gcc.html">这篇文章</a>。</p>
<p>首先安装依赖：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">xcode-select --install<br>brew install git glm libpng freetype glew libxml2<br></code></pre></td></tr></tbody></table></figure>
<p>安装Pmw：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/schrodinger/pmw-patched.git<br><span class="hljs-built_in">cd</span> pmw-patched<br>sudo python setup.py install<br><span class="hljs-built_in">cd</span> ..<br>rm -rf pmw-patched<br></code></pre></td></tr></tbody></table></figure>
<p>获取pymol源代码并编译安装：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/schrodinger/pymol-open-source.git<br><span class="hljs-built_in">cd</span> pymol-open-source<br><span class="hljs-built_in">export</span> PREFIX_PATH=/usr/<span class="hljs-built_in">local</span><br>python3 setup.py build install --home=<span class="hljs-variable">$HOME</span>/Applications/pymol --no-vmd-plugins --<span class="hljs-built_in">jobs</span> 4<br></code></pre></td></tr></tbody></table></figure>

<p>最后将路径添加到<code>PATH</code>:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">'export PATH=$PATH:$HOME/Applications/pymol/bin'</span> &gt;&gt; <span class="hljs-variable">$HOME</span>/.bash_profile<br></code></pre></td></tr></tbody></table></figure>

<p>编译成功后的版本没有命令行窗口，只有预览窗口，所以不建议在Mac上编译pymol进行绘制，把做好的工程文件拿来渲染出个图还行，编辑绘图还是去用Schrödinger的发行版吧。<br><img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjv1m0saybj30o60r1wxf.jpg" title="基于X11的PyMOL界面"></p>
]]></content>
      <categories>
        <category>PyMOL系列教程</category>
      </categories>
  </entry>
  <entry>
    <title>PyQt5多线程编程</title>
    <url>/python-xue-xi-bi-ji/pyqt5-duo-xian-cheng-bian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单位的公共仪器需要预约才能够使用，但是自从预约时间改到了早上，就很不好约了，所以决定写一个程序实现自动预约。由于还要分享给实验室其它同学使用，就得写一个GUI了，这一下代码量瞬间变成了原来的10倍，不过学到了些新东西，这波不亏。</p>
<p>在图形化编程中一个很重要的一点就是使用多线程，将UI线程独立出来。如果你的程序不存在会造成线程阻塞的操作，不使用多线程倒也没什么大问题，但是如果存在像联网、读写文件等可能需要等待的操作，使用单线程就可能会造成UI假死，这对于用户体验来说是非常不友好的。例如微软的office套件为了兼容老式CPU，IO等操作都是使用的UI的线程，打开或保存大文件时，用户界面无响应；而像photoshop这样的程序由于使用了多线程，即使有大量的IO行为，UI也可以响应用户的操作。</p>
<p>Qt引以为豪的对象通讯机制被称为<strong>信号-槽</strong>(<strong>signal-slot</strong>)机制。当特定事件被触发时（如子线程结束）将发送一个信号，而与该信号建立的连接槽，则可以接收到该信号并做出反应(根据子线程的返回值执行操作)。</p>
<p>在我的程序中，需要在仪器开放预约前不断查询，在开放预约的第一刻立即提交表单，而为了不拖垮服务器，需要在每次查询后让线程休眠一会。如果所有这些操作都在主线程中完成，那么线程休眠的时候UI就会无响应，在我的程序中就表现为点击开始查询后UI就一直处于无响应状态，直到预约成功后才恢复响应。</p>
<p>因此，就需要新建一个线程，这个线程只用来发送信号调用查询函数，发送完毕后即休眠，等待下一次发送或任务完成后结束线程。</p>
<img src="https://tva2.sinaimg.cn/large/005Vgpymly1gjv1m17p0oj316u0bgwgh.jpg" title="灵魂画手的流程图." alt="灵魂画手的流程图.">

<hr>
<p>要创建一个新线程，需要在程序中定义一个类，这个类要继承<code>QtCore.QThread</code>，然后把要执行的操作放进<code>run()</code>函数中，线程启动后，就会自动运行这个函数。结束线程时通过调用线程的<code>terminate()</code>方法来中止线程：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryWaitThread</span>(<span class="hljs-params">QtCore.QThread</span>):</span><br>    <span class="hljs-comment"># 定义线程需要用到的信号</span><br>    query_signal = QtCore.pyqtSignal()      <span class="hljs-comment"># 查询信号</span><br>    on_complete = QtCore.pyqtSignal(int)    <span class="hljs-comment"># 每次查询完成时发送，可以发送参数，</span><br>												此处参数int为查询次数<br>    terminate_thread = QtCore.pyqtSignal()  <span class="hljs-comment"># 结束线程信号</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        super(QueryWaitThread, self).__init__()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 只发送信号，然后休眠。</span><br>        i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            self.on_complete.emit(i)		<span class="hljs-comment"># 调用信号的emit()方法</span><br>            i += <span class="hljs-number">1</span><br>            self.query_signal.emit()<br>            sleep(<span class="hljs-number">60</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kill_thread</span>(<span class="hljs-params">self</span>):</span><br>        self.terminate()<br></code></pre></td></tr></tbody></table></figure>

<p>我的查询函数与验证函数：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auto_query</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment">################</span><br>    <span class="hljs-comment">#    查询操作   #</span><br>    <span class="hljs-comment">################</span><br>    <span class="hljs-keyword">if</span> self.good_to_submit():<br>        self.btnstop.hide()<br>        self.btn_resel.show()<br>        main.Appoint(self)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_to_submit</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-comment"># 还无法提交表单:</span><br>    	<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    self.T.terminate_thread.emit() <span class="hljs-comment"># 验证可以提交表单后发送中止信号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_current_count</span>(<span class="hljs-params">self, i</span>):</span><br>    self.normalOutputWritten(<span class="hljs-string">"当前为第 %i 次查询...\n"</span> % i)<br></code></pre></td></tr></tbody></table></figure>

<p><code>self.normalOutputWritten()</code>是一个我自己定义的函数，用于在窗体的文本框中打印信息，你也可以定义自己的这类函数。</p>
<p>定义好信号以后，接下来需要调用信号的<code>connect()</code>方法将信号连接到需要执行函数上。下面的<code>start()</code>和<code>stop()</code>是窗体按钮按下后执行的操作，我们在这两个函数中使用刚刚定义好的信号：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment">################</span><br>    <span class="hljs-comment"># do something #</span><br>    <span class="hljs-comment">################</span><br>    self.T = QueryWaitThread()<br>    self.T.query_signal.connect(self.auto_query)<br>    self.T.on_complete.connect(self.print_current_count)<br>    self.T.terminate_thread.connect(self.T.kill_thread)<br>    self.normalOutputWritten(<span class="hljs-string">"已开启自动查询，当有符合条件的时间段时将自动提交预约...\n"</span>)<br>    self.T.start()  <span class="hljs-comment"># 开始执行线程函数</span><br>    self.btnstop.show()<br>    self.btn_resel.hide()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self</span>):</span><br>    self.btnstop.hide()<br>    self.btn_resel.show()<br>    self.T.terminate_thread.emit() <span class="hljs-comment"># 发送中止信号</span><br>    self.normalOutputWritten(<span class="hljs-string">"用户终止查询。\n"</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>当按下开始按钮后，程序会构造出一个线程<code>T</code>，执行到<code>T.start()</code>后，其中的<code>run()</code>函数便会进入<code>while</code>循环，不断发送查询信号，直到<code>good_to_submit()</code>函数返回<code>True</code>表明已经可以提交表单，或者当停止按钮按下后终止。</p>
<p>改进后的程序只是将定时功能分离了出来，实际上联网查询功能还是使用主线程完成的，在程序等待服务器返回数据的过程中UI还是会有短暂的无响应时间，不过这是在用户点击后产生的，因此对体验影响不大。但是，严格来说联网也应该分离出一个线程，毕竟服务器有时候返回会很慢，这时候如果你的用户是一个暴躁老哥，还是会对体验有影响的。</p>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python中使用百分号格式化字符串</title>
    <url>/python-xue-xi-bi-ji/python-zhong-shi-yong-bai-fen-hao-ge-shi-hua-zi-fu-chuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我最早学习的是C++语言，对于C风格的这种字符串格式化方式不熟悉，转到Python之后觉得这种方式可以很方便地在字符串中插入变量，于是去搜索了python的官方文档，找到了一个关于<a href="https://docs.python.org/2.4/lib/typesseq-strings.html">字符串格式化</a>的页面。</p>
<p>这种格式化方法的使用方式是<code>format % values</code>，其中format是字符串，value就是要插入的值。在format中，需要用值替换的位置用转换说明符(conversion specifier)进行占位，转换说明符是一组以%开头的字符，例如：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">17</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>string = <span class="hljs-string">"Tom is %s years old."</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print(string % age)<br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span> years old.<br></code></pre></td></tr></tbody></table></figure>

<p>在上例中，<code>%s</code>即转换说明符，<code>s</code> 表示将value转换成字符串类型，python会在内部调用<code>str(age)</code>，并把返回的字符串<code>"17"</code>插入到原来<code>%s</code>所在的位置。当然，对于上例中value是数值的情况，也可以使用整型类型说明符<code>d</code>或<code>i</code>，二者效果相同：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %d years old."</span> % age)<br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span> years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %i years old."</span> % age)<br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span> years old.<br></code></pre></td></tr></tbody></table></figure>

<p>如果format只需要一个参数，就像上例中的那样，那么后面的value必须是一个非元组对象(non-tuple object)。如果format需要多个参数，value就得是一个含有恰好满足format参数数量个元素的元组：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>age2 = <span class="hljs-number">16</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %s years old \</span><br><span class="hljs-string">while his brother Bob is %s years old."</span> % (age, age2))<br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span> years old <span class="hljs-keyword">while</span> his brother Bob <span class="hljs-keyword">is</span> <span class="hljs-number">16</span> years old.<br></code></pre></td></tr></tbody></table></figure>

<p>使用字典作为value也是可以的，这种方法必须在format中写明字典的键，并用括号括起来：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %(Tom)s years old \</span><br><span class="hljs-string">while his brother Bob is %(Bob)s years old."</span> % {<span class="hljs-string">'Tom'</span>: age, <span class="hljs-string">'Bob'</span>: age2})<br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span> years old <span class="hljs-keyword">while</span> his brother Bob <span class="hljs-keyword">is</span> <span class="hljs-number">16</span> years old.<br></code></pre></td></tr></tbody></table></figure>

<p>format中的转换说明符一共由7部分构成，按照排列顺序依次是：<br>**<code>"%" 映射键 转换标记 最小字段宽度 精度 长度限定 转换类型</code>**<br>其中仅有起始的百分号%和末尾的转换类型是必须的，中间的5个部分都是可选参数。映射键需要使用小括号括起来，如上例中的字典键。</p>
<p>转换标记有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">转换标记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#</td>
<td>转换将会使用下方定义的替代形式</td>
</tr>
<tr>
<td align="center">0</td>
<td>对于数值形式的转换，用 “0” 补齐空位</td>
</tr>
<tr>
<td align="center">-</td>
<td>居左 (如果与 “0” 同时出现，将会覆盖 “0”).</td>
</tr>
<tr>
<td align="center"></td>
<td>(空格) 转换有符号的值时，在正数前加上一个空格</td>
</tr>
<tr>
<td align="center">+</td>
<td>转换有符号的值时，在正数前加上 “+” (会覆盖空格标记)</td>
</tr>
</tbody></table>
<p>这些符号常和精度一起使用，精度既可以指定整数也可以指定小数，指定小数时需要加上小数点<code>"."</code>：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %3d years old."</span> % age)  <span class="hljs-comment"># 整数占三位</span><br>Tom <span class="hljs-keyword">is</span>  <span class="hljs-number">17</span> years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is % d years old."</span> % age)  <span class="hljs-comment"># 加空格</span><br>Tom <span class="hljs-keyword">is</span>  <span class="hljs-number">17</span> years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %03d years old."</span> % age)  <span class="hljs-comment"># 用0补齐空位</span><br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">017</span> years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %-3d years old."</span> % age)  <span class="hljs-comment"># 居左</span><br>Tom <span class="hljs-keyword">is</span> <span class="hljs-number">17</span>  years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %+d years old."</span> % age)  <span class="hljs-comment"># 添加+号</span><br>Tom <span class="hljs-keyword">is</span> +<span class="hljs-number">17</span> years old.<br><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">"Tom is %+.2f years old."</span> % age)  <span class="hljs-comment"># 指定小数位数</span><br>Tom <span class="hljs-keyword">is</span> +<span class="hljs-number">17.00</span> years old.<br></code></pre></td></tr></tbody></table></figure>

<p>转换类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">转换类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td>十进制有符号整型</td>
</tr>
<tr>
<td align="center">i</td>
<td>十进制有符号整型</td>
</tr>
<tr>
<td align="center">o</td>
<td>无符号八进制</td>
</tr>
<tr>
<td align="center">u</td>
<td>无符号十进制</td>
</tr>
<tr>
<td align="center">x</td>
<td>无符号十六进制（小写）</td>
</tr>
<tr>
<td align="center">X</td>
<td>无符号十六进制（大写）</td>
</tr>
<tr>
<td align="center">e</td>
<td>浮点指数格式（小写）</td>
</tr>
<tr>
<td align="center">E</td>
<td>浮点指数格式（大写）</td>
</tr>
<tr>
<td align="center">f</td>
<td>十进制浮点格式</td>
</tr>
<tr>
<td align="center">F</td>
<td>十进制浮点格式</td>
</tr>
<tr>
<td align="center">g</td>
<td>若指数大于-4或小于精度则于”e”相同，其他情况为”f”</td>
</tr>
<tr>
<td align="center">G</td>
<td>若指数大于-4或小于精度则于”E”相同，其他情况为”F”</td>
</tr>
<tr>
<td align="center">c</td>
<td>单字符（接受整型或单字符的字符串类型）</td>
</tr>
<tr>
<td align="center">r</td>
<td>字符串（使用repr()转换python对象）</td>
</tr>
<tr>
<td align="center">s</td>
<td>字符串（使用str()转换python对象）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>youtube-dl的使用及编程应用</title>
    <url>/python-xue-xi-bi-ji/youtube-dl-de-shi-yong-ji-bian-cheng-ying-yong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>YouTube上有许多精彩视频，曾经chrome的应用商店里有一个叫VideoDownloader的插件可以一键下载YouTube视频，但是已经被Google封杀了。后来我发现了youtube-dl这个工具，它不仅可以用来下载YouTube视频，国内的一些视频站也可以用它进行下载。 </p>
<p>这个程序是一个开源的python项目，详情可以访问它的<a href="http://rg3.github.io/youtube-dl/">官方网站</a>。由于是开源项目，因此支持MacOS、Linux和Windows平台，可以在官网直接下载编译好的程序。</p>
<p>若需要使用源代码，可以使用pip安装到本地：<br><code>sudo -H pip3 install --upgrade youtube-dl</code></p>
<p>YouTube上面视频和音频是分开存放的，当然也有合成好的，不过画质就比较一般了，想要下载高质量视频，就得分别下载音频和视频，然后再使用ffmpeg将他们合成在一起。ffmpeg的<a href="https://www.ffmpeg.org/download.html">下载地址</a>在这，这同样也是个开源项目，但是我们只下载它打包好的程序就可以了。</p>
<p>全都下载好后，可以把这些程序都放在同一个目录下，像这样，会有4个文件：<br><img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjv1m07ydjj30qy03mjs6.jpg"><br>然后把该目录添加到PATH中，就可以在任意位置使用了。</p>
<p>youtube-dl的使用非常简单，选择好要下载的文件，它会自动调用ffmpeg合成音视频，不过就是没有GUI，每次使用都得输一串命令，而且对于国内用户，还需要指定代理服务器，更增加了命令的输入量。</p>
<ul>
<li>获取视频信息：</li>
</ul>
<p><code>youtube-dl -F https://www.youtube.com/watch?v=gOLlY7SV6gE --proxy 'socks5://127.0.0.1:1086'</code></p>
<p>这里我使用的是shadowsocks代理，地址和端口号可以在你的ss程序中找到，等待程序下载完成后，就会看到视频信息了。</p>
<img src="https://tvax1.sinaimg.cn/large/005Vgpymly1gjv1m0g1tnj30yg0n0e1j.jpg">

<ul>
<li>下载视频</li>
</ul>
<p>我们选择下载最高质量的音视频，通过观察视频信息可知，该视频最高质量为3840x1920 60fps，代号315，音频为码率149k的文件，代号251，然后下载这两个文件：<br><code>youtube-dl -f 315+251 https://www.youtube.com/watch?v=gOLlY7SV6gE --proxy 'socks5://127.0.0.1:1086'</code></p>
<img src="https://tva1.sinaimg.cn/large/005Vgpymly1gjv1m0ylwtj30yg06twm3.jpg">

<p>程序默认将下载好的文件置于用户的根目录下。</p>
<p>虽说只输了两次命令，但是还是不够方便，不过好在程序开源，我们可以自己开发一个GUI。本文将使用PyQt5制作一个简单的GUI，实现可视化操作。其实做GUI就是要把命令行指令做进按钮里，再把它的输入输出显示在窗体上。有了这样的思路，我们首先来分析youtube-dl返回的数据。</p>
<p>以下是python代码：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> youtube_dl<br><br>ydl_opts = ({<span class="hljs-string">'outtmpl'</span>: <span class="hljs-string">'%(title)s%(ext)s'</span>,<br>             <span class="hljs-string">'proxy'</span>: <span class="hljs-string">'127.0.0.1:1087'</span>}) <span class="hljs-comment"># 默认HTTP代理</span><br><br><span class="hljs-comment"># retrieve video information</span><br><span class="hljs-keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="hljs-keyword">as</span> ydl:<br>    video = ydl.extract_info(<span class="hljs-string">'https://www.youtube.com/watch?v=gOLlY7SV6gE'</span>,<br>                              download=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>把video打印出来查看，是一个巨大的字典，里面包含了视频的所有信息，我们需要的视频分辨率信息，都在该字典的formats键值中，而formats又是一个字典列表，该视频中的每个文件都是一个字典。</p>
<p>继续处理formats，得到需要的信息：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># sort information</span><br>formats = video.get(<span class="hljs-string">'formats'</span>)<br>file_count = len(formats)<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> formats:<br>    format_code.append(f.get(<span class="hljs-string">'format_id'</span>))<br>    extension.append(f.get(<span class="hljs-string">'ext'</span>))<br>    resolution.append(ydl.format_resolution(f))<br>    format_note.append(f.get(<span class="hljs-string">'format_note'</span>))<br>    file_size.append(f.get(<span class="hljs-string">'filesize'</span>))<br></code></pre></td></tr></tbody></table></figure>

<p>使用get方法获得字典键值的好处就是，如果字典中不存在该键值，就会返回None，如果使用索引直接访问不存在的键值，则会抛出异常。</p>
<p>现在我们已经拿到了所需的全部数据，接下来就是要在窗体中显示了。在PyQt5中，<code>QTableWidget</code>可以做这件事：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py">self.tableWidget = QtWidgets.QTableWidget(Form)<br>self.tableWidget.setRowCount(main.file_count)<br>self.tableWidget.setColumnCount(<span class="hljs-number">5</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>然后使用循环将数据填入表格：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FillInfo</span>(<span class="hljs-params">w</span>):</span>            <span class="hljs-comment"># fill information into table</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, file_count):<br>        w.tableWidget.setItem(i, <span class="hljs-number">0</span>, QTableWidgetItem(format_code[i]))<br>        w.tableWidget.setItem(i, <span class="hljs-number">1</span>, QTableWidgetItem(extension[i]))<br>        w.tableWidget.setItem(i, <span class="hljs-number">2</span>, QTableWidgetItem(resolution[i]))<br>        w.tableWidget.setItem(i, <span class="hljs-number">3</span>, QTableWidgetItem(format_note[i]))<br>        w.tableWidget.setItem(i, <span class="hljs-number">4</span>, QTableWidgetItem(str(file_size[i])))<br></code></pre></td></tr></tbody></table></figure>

<p>youtube-dl的作者并没有给这个项目单独写一个文档，所有的信息都需要去源代码中看，经过阅读源代码，我终于找到了一个名为<code>process_video_result</code>的函数，可以指定下载哪个文件。它接受<code>extract_info</code>返回的字典对象，根据用户输入的命令行参数选择文件进行下载，所以我们只需要把需要下载的视频的format_id填入参数列表，再把视频信息字典传给函数，就可以实现指定下载的功能了。</p>
<p>创建一个编辑框，然后取得该编辑框的输入：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py">self.SeleEdit = QtWidgets.QLineEdit(Form)<br>self.SeleEdit.setObjectName(<span class="hljs-string">"SeleEdit"</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">self</span>):</span><br>    ydl.params = {<span class="hljs-string">'format'</span>: self.SeleEdit.text()}<br>    <span class="hljs-keyword">try</span>:<br>        main.ydl.process_video_result(main.video)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></tbody></table></figure>

<p>应该像使用命令行程序那样输入format_id，对于两个文件的情况，youtube-dl只接受<code>'video+audio'</code>的形式，如果顺序颠倒则会抛出异常。</p>
<img src="https://tva1.sinaimg.cn/large/005Vgpymly1gjv1m0nigqj30yg0eqjw4.jpg" title="程序截图">


<p>完整的代码可以在我的<a href="https://github.com/SSSSSimon/youtube-dl-GUI">Github</a>上找到。</p>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>使用Vina进行分子对接</title>
    <url>/ji-suan-hua-xue/docking-vina/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用Vina进行分子对接，各种蛋白与配体文件均需使用pdbqt格式，scripps研究所提供了Autodock Tools可以进行可视化转换。下面是使用adt准备文件的步骤：</p>
<ul>
<li>安装好adt后，在终端内输入adt以启动。</li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ adt<br></code></pre></td></tr></tbody></table></figure>

<img src="https://tvax1.sinaimg.cn/large/005Vgpymly1gjv1llzrwjj317e0xsgpd.jpg" title="Autodock Tools" width="50%" height="50%">

<hr>
<ul>
<li><p>处理大分子</p>
<p>  <strong>File -&gt; Read Molecule -&gt; Open</strong></p>
<p>  <strong>Edit -&gt; Hydrogens -&gt; Add -&gt; Polar Only -&gt; OK</strong></p>
<p>  <strong>Grid -&gt; Macromolecule -&gt; Choose -&gt; Select molecule -&gt; Save</strong></p>
</li>
</ul>
<p>将大分子保存为pdbqt文件后，大分子的处理就完成了。</p>
<hr>
<ul>
<li><p>限定搜索区域</p>
<p>  <strong>Grid -&gt; Grid Box</strong> </p>
</li>
</ul>
<img src="https://tvax2.sinaimg.cn/large/005Vgpymly1gjv1llr4k7j31800ww79p.jpg" title="划定搜索区域" width="50%" height="50%">

<p>这里调整好后不用保存，需要把它们记录在文本文件中备用。</p>
<p><font color="#FF0000"><strong>注意</strong></font>：与Autodock4不同，Vina中的空间单位为埃（Å），需先将<code>Spacing</code>调至1再调整xyz。</p>
<hr>
<ul>
<li><p>处理小分子</p>
<p>  <strong>Ligand -&gt; Input -&gt; Open</strong> </p>
<p>  <strong>Ligand -&gt; Torsion Tree -&gt; Choose Torsion</strong></p>
<p>  按住Shift再单击键以切换扭转类型，可以先在DashBoard中将大分子隐藏。</p>
<p>  <strong>Ligand -&gt; Output -&gt; Save as PDBQT -&gt; Save</strong></p>
</li>
</ul>
<p>处理完文件后即可进行分子对接</p>
<hr>
<ul>
<li>Redocking</li>
</ul>
<p>运行Vina需要给它提供一个配置文件，写法如下，random seed是可选项：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">receptor</span> = ./PDBQT/<span class="hljs-number">5</span>un1.pdbqt<br><span class="hljs-attr">ligand</span> = ./PDBQT/mk-<span class="hljs-number">801</span>.pdbqt<br><br><span class="hljs-attr">center_x</span> = <span class="hljs-number">24.188</span><br><span class="hljs-attr">center_y</span> = -<span class="hljs-number">14.09</span><br><span class="hljs-attr">center_z</span> = <span class="hljs-number">108.227</span><br><br><span class="hljs-attr">size_x</span> = <span class="hljs-number">20</span><br><span class="hljs-attr">size_y</span> = <span class="hljs-number">20</span><br><span class="hljs-attr">size_z</span> = <span class="hljs-number">20</span><br><br><span class="hljs-attr">out</span> = ./DockingResult/rslt-mk801.pdbqt<br><span class="hljs-attr">log</span> = ./log/log-mk801.log<br><br><span class="hljs-attr">seed</span> = -<span class="hljs-number">1661955048</span><br><span class="hljs-attr">exhaustiveness</span> = <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure>
<p>保存为mk801-conf.txt，然后就可以运行vina了。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ vina --config mk801-conf.txt<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>对接目标化合物</li>
</ul>
<p>对接目标化合物的过程同上。对于分子对接的结果一定要谨慎对待，因为无论给定的分子有没有活性、是否契合活性口袋，程序都能给出一个结果，一定要根据相互作用知识来进行判断。</p>
<p>最后，需要调用<code>MGLTools</code>里的python脚本将pdbqt转换成pdb，就可以在各种可视化程序中查看了。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ convertqt=mglTools/MGLToolsPckgs/AutoDockTools/Utilities24/pdbqt_to_pdb.py<br>$ pythonsh <span class="hljs-variable">$convertqt</span> -s rslt-mk801.pdbqt<br></code></pre></td></tr></tbody></table></figure>
<p>原始的脚本只能将对接产生的能量最低的一个结构输出出来，如果你需要把所有结构都输出的话，需要修改两个函数：</p>
<p>找到<code>MolKit/pdbWriter.py</code>，在<code>write</code>函数后面定义一个新函数，名叫<code>write2</code>，函数定义如下：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write2</span>(<span class="hljs-params">self, filename, nodes, sort=False, sortFunc=None,</span></span><br><span class="hljs-function"><span class="hljs-params">          records=[<span class="hljs-string">'ATOM'</span>, <span class="hljs-string">'CONECT'</span>], bondOrigin=(<span class="hljs-params"><span class="hljs-string">'File'</span>,<span class="hljs-string">'UserDefined'</span></span>),</span></span><br><span class="hljs-function"><span class="hljs-params">          ssOrigin=<span class="hljs-string">'File'</span></span>):</span><br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    required argument:</span><br><span class="hljs-string">    filename  -- path to the new file, a .pdb extension will be added</span><br><span class="hljs-string">                 when missing.</span><br><span class="hljs-string">    nodes     -- TreeNode, TreeNodeSet instance to save as PDB</span><br><span class="hljs-string"></span><br><span class="hljs-string">    optional arguments:</span><br><span class="hljs-string">    sort  -- (False) Boolean flag to specify whether or not to sort the</span><br><span class="hljs-string">             given nodes</span><br><span class="hljs-string">    sortFunc  -- (None) sort function that will be used to sort the nodes</span><br><span class="hljs-string">                 when specified.This function has to return (-1, 0 or 1).</span><br><span class="hljs-string">    records -- list of PDB record to write out</span><br><span class="hljs-string">    bondOrigin -- (('File', 'UserDefined')) This will be used if the CONECT records are</span><br><span class="hljs-string">                  written out. Can be any combination of 'File',</span><br><span class="hljs-string">                  'BuiltByDistance' and 'UserDefined'.</span><br><span class="hljs-string">    ssOrigin -- 'File' This will be used if the TURN, HELIX and SHEET</span><br><span class="hljs-string">                 records are written. Can be either from the originating</span><br><span class="hljs-string">                 PDB file or from the data structure.</span><br><span class="hljs-string">    """</span><br>    self.records = records<br>    <span class="hljs-comment"># If the filename doesn't have a pdb extension add it</span><br>    fileExt = os.path.splitext(filename)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> fileExt==<span class="hljs-string">''</span>:<br>        filename = <span class="hljs-string">'%s.pdb'</span> %filename<br>    <span class="hljs-comment"># Nodes need to be either a TreeNode or a TreeNodeSet instance.</span><br>    <span class="hljs-keyword">assert</span> isinstance(nodes, TreeNode) <span class="hljs-keyword">or</span> isinstance(nodes, TreeNodeSet)<br>    <br>    <span class="hljs-comment"># sort the nodes</span><br>    <span class="hljs-keyword">if</span> sort <span class="hljs-keyword">and</span> hasattr(nodes, <span class="hljs-string">'sort'</span>):<br>        nodes.sort(sortFunc)<br><br>    <span class="hljs-keyword">if</span> isinstance(nodes, TreeNode): mol = nodes.top   <br>    <span class="hljs-keyword">elif</span> isinstance(nodes, TreeNodeSet): mol = nodes.top.uniq()[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># get a handle on the molecule parser</span><br>    parser = mol.parser<br><br>    <span class="hljs-comment"># get the atoms in nodes</span><br>    atmInNode = nodes.findType(Atom)<br>    <br>    <span class="hljs-comment"># Create all the records to be written out.</span><br>    <span class="hljs-comment"># Get the from file records this is possible only if the file</span><br>    <span class="hljs-comment"># comes from a PDB parser.</span><br>    <span class="hljs-keyword">if</span> isinstance(parser, PdbParser):<br>        fileRec = filter(<span class="hljs-keyword">lambda</span> x: <span class="hljs-keyword">not</span> x <span class="hljs-keyword">in</span> self.FROMDATASTRUCT, records)<br>        <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> fileRec:<br>            self.recordsToWrite[rec] = parser.getRecords(parser.allLines,rec)<br><br>    <span class="hljs-comment"># Create the records from the data structure:</span><br>    <span class="hljs-comment"># secondary structure 'HELIX', 'SHEET', 'TURN', 'REMARK 650 HELIX',</span><br>    <span class="hljs-comment"># 'REMARK 700 SHEET', 'REMARK 750 TURN'</span><br>    ssRec = filter(<span class="hljs-keyword">lambda</span> x: x <span class="hljs-keyword">in</span> [<span class="hljs-string">'HELIX'</span>, <span class="hljs-string">'SHEET'</span>, <span class="hljs-string">'TURN'</span>], records)<br>    <span class="hljs-keyword">if</span> len(ssRec):<br>        self.defineSecondaryStructureSection(mol, origin=ssOrigin)<br><br>    <span class="hljs-comment"># Atom records (ATOM, TER and HETATM)</span><br>    atmRec = <span class="hljs-string">'ATOM'</span> <span class="hljs-keyword">in</span> records<br>    hetRec = <span class="hljs-string">'HETATM'</span> <span class="hljs-keyword">in</span> records<br>    <span class="hljs-keyword">if</span> atmRec <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> hetRec <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> : <br>        <span class="hljs-comment">#self.defineCoordsSection(nodes, sort=sort, sortFunc=sortFunc, atmRec=atmRec, hetRec=hetRec)</span><br>        self.defineCoordsSection(atmInNode, sort=sort, sortFunc=sortFunc, atmRec=atmRec, hetRec=hetRec)<br>        <br>    <span class="hljs-comment"># Hydrogen bonds (HYDBND)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">'HYDBND'</span> <span class="hljs-keyword">in</span> records:<br>        self.defineHYDBNDRecords(atmInNode)<br><br>    <span class="hljs-comment"># CONECT records</span><br>    <span class="hljs-comment">#build excluded Bonds from recType here</span><br>    <span class="hljs-comment">#possible recTypes are:</span><br>    <span class="hljs-comment">#all, fileUser, fileDist, file, user, userDist, dist, none</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">'CONECT'</span> <span class="hljs-keyword">in</span> records:<br>        self.defineConnectSection(atmInNode, bondOrigin)<br><br>    file = open(filename, <span class="hljs-string">'a'</span>)      <br><br>    <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> self.PDBRECORDS:<br>        <span class="hljs-keyword">if</span> self.recordsToWrite.has_key(rec):<br>            recLine = self.recordsToWrite[rec]<br>            <span class="hljs-keyword">if</span> type(recLine) <span class="hljs-keyword">is</span> types.ListType:<br>                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> recLine:<br>                    file.write(line)<br>            <span class="hljs-keyword">else</span>:<br>                file.write(line)<br>    file.close()<br>    <br>    <span class="hljs-comment">#self.recordsToWrite = {}</span><br></code></pre></td></tr></tbody></table></figure>
<p>然后找到<code>MGLToolsPckgs/AutoDockTools/Utilities24/pdbqt_to_pdb.py</code>，把它复制一份，命名为<code>pdbqt_to_pdb2.py</code>，将里面的<code>mols = Read(pdbqt_filename)</code>一直到最后的代码替换成如下所示：</p>
<figure class="highlight py"><table><tbody><tr><td class="code"><pre><code class="hljs py">mols = Read(pdbqt_filename)<br>mol2 = []<br><br><span class="hljs-keyword">if</span> verbose: <span class="hljs-keyword">print</span> <span class="hljs-string">'read '</span>, pdbqt_filename    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mols:<br>    mol = i<br>    mol.buildBondsByDistance()<br>    <span class="hljs-comment">#fix number for problem files with alternative positions</span><br>    mol.allAtoms.number = range(<span class="hljs-number">1</span>, len(mol.allAtoms)+<span class="hljs-number">1</span>)<br>    mol2.append(mol)<br>    <br><span class="hljs-comment">#pdb_filename = mol.name + '.pdb'</span><br>writer = PdbWriter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(mol2)):<br>    file = open(pdb_filename, <span class="hljs-string">'a'</span>)<br>    file.write(<span class="hljs-string">'MODEL '</span>)<br>    file.write(str(i+<span class="hljs-number">1</span>))<br>    file.write(<span class="hljs-string">'\n'</span>)<br>    file.close()<br>    writer.write2(pdb_filename, mol2[i].allAtoms, records=[<span class="hljs-string">'ATOM'</span>, <span class="hljs-string">'HETATM'</span>])<br><br><span class="hljs-keyword">if</span> verbose:<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">"wrote "</span>, ctr, <span class="hljs-string">" atoms to"</span>, pdb_filename<br></code></pre></td></tr></tbody></table></figure>
<p>最后运行脚本的时候就用<code>pdbqt_to_pdb2.py</code>就可以了，其他的照抄，就能把对接出的所有结构都转换出来了。</p>
]]></content>
      <categories>
        <category>计算化学</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始学习ECD计算</title>
    <url>/ji-suan-hua-xue/ecd-ji-suan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一种完全使用免费软件计算ECD光谱的较详细过程，产生的结果具有较好的理论意义，阅读本文需要掌握基本的Linux指令，否则可能会对本文的命令操作产生困惑。</p>
<h1 id="计算ECD的大致过程为："><a href="#计算ECD的大致过程为：" class="headerlink" title="计算ECD的大致过程为："></a>计算ECD的大致过程为：</h1><ul>
<li><ol>
<li>产生数个优势构象。</li>
</ol>
</li>
<li><ol start="2">
<li>对优势构象做振动分析，得到其对应的自由能校正量。</li>
</ol>
</li>
<li><ol start="3">
<li>计算优势构象的高精度电子能量，即单点能(Single Point Energy)。</li>
</ol>
</li>
<li><ol start="4">
<li>将自由能校正量和高精度单点能相加，得到构象的精确自由能，以此计算玻尔兹曼分布。</li>
</ol>
</li>
<li><ol start="5">
<li>计算各个构象的激发态。</li>
</ol>
</li>
<li><ol start="6">
<li>根据激发态和玻尔兹曼分布绘制出最终的ECD图像。</li>
</ol>
</li>
</ul>
<p>下面将分步骤详细介绍软件操作。</p>
<h2 id="产生优势构象"><a href="#产生优势构象" class="headerlink" title="产生优势构象"></a>产生优势构象</h2><p>需要用到软件有，molclus软件包（包括<code>gentor</code>、<code>molclus</code>、<code>isostat</code>）、<code>Gaussian</code>（可选）、<code>MOPAC</code>、<code>ORCA</code>。</p>
<p>登录进服务器主节点后输入<code>cd molclus_1.9.6/</code>，再输入<code>ls</code>可以看到其包含的文件：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 给新手的提示："$"为提示符，其后跟的字符串是要输入的命令，下方没有$的行是命令的输出结果</span><br>$ <span class="hljs-built_in">cd</span> molclus_1.9.6/<br>$ ls<br>LICENSE.txt*   gentor/        molclus*       template.gjf*  template.mop*  xyz2QC*<br>genmer/        isostat*       settings.ini*  template.inp*  template2.gjf*<br></code></pre></td></tr></tbody></table></figure>
<p>其中<code>gentor</code>可以用来产生分子的各种构象，将3D的分子结构根据<code>gentor.ini</code>中的设定进行枚举，产生大量构象；<code>molclus</code>可以调用各类计算软件对构象进行优化，并计算其自由能；<code>isostat</code>可以统计优化后的各个构象能量，并对他们进行排序；<code>genmer</code>可以用来生成分子团簇的构象；其他<code>template</code>文件则为计算软件的输入模版文件。</p>
<p>在本文中，使用了<code>gentor</code>来产生初始构象，如果分子的柔性特别好，可旋转的键数量太多，需要用<code>gromacs</code>生成最初的构象，如果使用<code>gentor</code>则计算量过于庞大。在<code>GaussView</code>里可以观察到原子标号，以此作为<code>gentor.ini</code>的设定时的标号方式，具体设定方式可以参见文章<a href="http://bbs.keinsci.com/thread-2388-1-1.html">gentor构象扫描</a>。</p>
<p>设定好<code>gentor.ini</code>后，把分子转换成xyz格式移动到<code>gentor</code>所在的目录下。 此处可以调用<code>openbabel</code>进行转换，假如待转换的分子文件名为<code>aaa.mol</code>，则输入<code>obabel aaa.mol -O mol.xyz</code>。完成后即可在当前目录下看到<code>mol.xyz</code>，必须是这个名字，一个字母都不能差：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> gentor<br>$ ls<br>gentor*  gentor.ini*  aaa.mol<br>$ obabel aaa.mol -O mol.xyz <br>1 molecule converted<br>$ ls<br>gentor*  gentor.ini*  aaa.mol mol.xyz<br></code></pre></td></tr></tbody></table></figure>
<p>启动<code>gentor</code>：输入<code>./gentor</code>，完成后即可在当前目录下看到<code>traj.xyz</code>文件：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ ./gentor<br>$ ls<br>gentor*  gentor.ini*  aaa.mol mol.xyz  traj.xyz<br></code></pre></td></tr></tbody></table></figure>
<p>如果产生的构象数量特别多，就需要先用<code>Gaussian</code>初步优化一下，如果构象数量不是很多，仅有数百个，那么直接使用<code>MOPAC</code>优化。此处对于我的分子，<code>traj.xyz</code>中含有9000多个构象，所以先用<code>Gaussian</code>优化。将<code>traj.xyz</code>移动到<code>molclus</code>目录下，修改<code>settings.ini</code>和<code>template.gjf</code>，关键词写<code>UFF=qeq opt</code>，然后运行<code>molclus</code>。可以参考<a href="http://bbs.keinsci.com/thread-577-1-1.html">molclus构象搜索</a>。这里我的机器上<code>Gaussian</code>配置了<code>Default.route</code>，所以在模板文件中就不单独指定%mem和%cpu了，你可以根据自己的情况决定使用哪种方式。</p>
<p>如果你的机器只有一个节点，那么可以像下面这样编辑好设置直接运行：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ mv traj.xyz ../<br>$ <span class="hljs-built_in">cd</span> ../<br>$ vi settings.ini <br>$ vi template.gjf<br>$ ./molclus<br></code></pre></td></tr></tbody></table></figure>
<p>但是如果你像我一样在计算集群上运行，有好几个节点，可以使用我编写的脚本<code>split_molclus.sh</code>，在<a href="https://github.com/SSSSSimon/ECD-widgets">我的github</a>上可以下载到。此脚本接受三个参数，分别是“份数”、“总构象数”、“程序编号”。<br>例如，<code>settings.ini</code>中<code>Gaussian</code>对于的程序编号为1，我的集群有3个节点，每节点都支持超线程，构象总共有9000个，那么就输入：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ ./split_molclus.sh 6 9000 1<br></code></pre></td></tr></tbody></table></figure>
<p>完成后就可以在当前目录下看到1 2 3 4 5 6共六个目录，每个目录中都有相同的文件，不同的是<code>settings.ini</code>中要计算的结构都被平均分了，这样在相应的节点运行目录内的<code>molclus</code>程序即可。运行完成后将六个目录中生成的<code>isomers.xyz</code>全部输出到一起去，可以编写一个循环：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..6}<br>&gt; <span class="hljs-keyword">do</span><br>&gt; cat <span class="hljs-variable">$i</span>/isomer* &gt;&gt; isomers.xyz<br>&gt; <span class="hljs-keyword">done</span><br></code></pre></td></tr></tbody></table></figure>
<p>这样，六个目录中的<code>isomers.xyz</code>就被汇总到了一起，现在可以输入<code>rm -rf {1..6}</code>把六个目录删掉了。接下来就要对汇总后的<code>isomers.xyz</code>进行分析，科音的sob老师编写的<code>isostat</code>程序就是用来干这个的，但是他这个程序遇到构象多的文件的时候就会特别慢，而且排序的时候会把整个文件里的构象全部进行排序。虽然没有开源，但是根据程序的输出可以推测就是使用了一个for循环加getline()函数读取文件，然后用了个sort()给数组排序。我之前用它统计过一个2万构象的文件，硬生生耗了我2个小时，这其实完全没有必要，因为我们给到下一步的构象只需要取能量最低的100个就可以了，把整个数组排序费事费力还做大量无用功，因此我编写了一个名为<code>get_first_100_geoms</code>的程序，使用了随机存取技术读取<code>isomers.xyz</code>，并只输出其中能量最低的100个构象到<code>isomers100.xyz</code>，笔者尝试过最高30万个构象的文件，即使是如此庞大的文件也可以在瞬间完成操作。文本文件其实按道理来说是不适合随机访问的，但是仔细观察sob老师的<code>molclus</code>输出的<code>isomers.xyz</code>可以发现其中的输出都是经过格式化的，这就给随机访问创造了可能，程序源代码同样可以在上文的github链接中下载到。需要注意的是，由于程序使用了某些C++11的特性，如果你的g++版本太低是没法编译的，比如CentOS自带的g++就不行，如果你使用CentOS需要先升级g++。要编译该程序，输入<code>g++ get_first_100_geoms.cpp -o get_first_100_geoms</code>即可。</p>
<p>运行完<code>get_first_100_geoms</code>，再输入<code>./isostat</code>运行<code>isostat</code>，分析<code>isomers100.xyz</code>，会得到<code>cluster.xyz</code>。然后使用<code>MOPAC</code>在<code>PM7</code>级别下进行优化，同样，这个也可以并行，根据自己的机器选择合适的方式：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ ./get_first_100_geoms<br>$ ./isostat<br>$ rm traj.xyz<br>$ mv cluster.xyz traj.xyz<br>$ vi settings.ini<br>$ vi template.mop<br>$ ./molclus<br></code></pre></td></tr></tbody></table></figure>
<p>输入<code>./isostat</code>运行<code>isostat</code>，敲三次回车开始分析，最后查看一下300K的玻尔兹曼分布。取几个占比高的构象（2kcal/mol以内）进行下一步，使用<code>ORCA</code>进行优化+振动分析，根据你的机器情况选择内存数量和CPU核心数量，对单个任务不要使用多于CPU物理核心的核心数量，<code>template.inp</code>关键词如下：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><code class="hljs angelscript">! B3LYP D3 <span class="hljs-number">6</span><span class="hljs-number">-311</span>G* RIJCOSX opt freq tightSCF miniprint nopop noautostart<br>%maxcore <span class="hljs-number">2000</span><br>%pal nprocs <span class="hljs-number">36</span> end<br></code></pre></td></tr></tbody></table></figure>
<p>然后按照同样的方法设置<code>settings.ini</code>，这里建议把备份输出文件的选项打开，然后再运行<code>molclus</code>：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ ./isostat<br>$ rm traj.xyz<br>$ mv cluster.xyz traj.xyz<br>$ vi settings.ini<br>$ vi template.inp<br>$ ./molclus<br></code></pre></td></tr></tbody></table></figure>

<h2 id="计算电子能量"><a href="#计算电子能量" class="headerlink" title="计算电子能量"></a>计算电子能量</h2><p>以下是<code>ORCA</code>输入文件的关键词，可以使用<code>Multiwfn</code>来生成输入文件，但记得添加<code>CFLOAT</code>关键词，否则会报内存不足的错误，我的机器上36核心128G内存会报错，如果你的内存更大可以不用加；另外，<strong>还需要加入SMD溶剂模型</strong>。参见<a href="http://sobereva.com/490">Multiwfn产生ORCA输入文件详解</a>：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">! PWPB95 D3 def2-TZVPP def2/J def2-TZVPP/C RIJCOSX CFLOAT grid4 gridx4 tightSCF noautostart miniprint nopop<br>%maxcore 2000<br>%pal nprocs 36 end<br>%cpcm<br>smd <span class="hljs-literal">true</span><br>SMDsolvent <span class="hljs-string">"methanol"</span><br>end<br></code></pre></td></tr></tbody></table></figure>
<p>然后在此处运行<code>xyz2QC</code>，选4生成分离的ORCA输入文件，载入上一步生成的<code>cluster.xyz</code>，选择要计算的构象，然后就会生成许多inp文件，ORCA官方建议为每个inp都建一个文件夹，然后把inp文件移进去计算。假设构象1的输入文件命名为<code>SP00001.inp</code>，输入以下命令运行<code>ORCA</code>：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 下面的命令会运行orca，将SP1.inp作为输入，把结果输出到SP1.out中，并忽略错误输出</span><br><span class="hljs-comment"># 一定要使用绝对路径调用orca</span><br>$ nohup <span class="hljs-variable">$HOME</span>/orca/orca SP1.inp &gt; SP1.out 2&gt; /dev/null &amp;<br></code></pre></td></tr></tbody></table></figure>
<p>计算完成后，输入以下命令即可看到电子能量：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ tail SP1.out -n 100 | grep <span class="hljs-string">"FINAL"</span><br>FINAL SINGLE POINT ENERGY     -1970.760258748528<br></code></pre></td></tr></tbody></table></figure>
<p>将此电子能量保存下来以备下一步使用，同样的方法可以获得构象2和构象3的电子能量。<br>##计算自由能和玻尔兹曼分布<br>详细用法看这里：<a href="http://sobereva.com/552">Shermo计算自由能和玻尔兹曼分布</a></p>
<p>在<code>Shermo</code>的目录下建立一个名为<code>list.txt</code>的文件。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span><br>$ <span class="hljs-built_in">cd</span> Shermo_2.0.3/<br>$ touch list.txt<br>$ vi list.txt<br></code></pre></td></tr></tbody></table></figure>
<p>将优化+振动分析一步的输出文件和得到的电子能量写入其中，格式为：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">/home/visitor/research/simon/orca1.out;-1970.760258748528<br>/home/visitor/research/simon/orca2.out;-1970.755539822519<br>/home/visitor/research/simon/orca3.out;-1970.754969829706<br></code></pre></td></tr></tbody></table></figure>
<p>保存并退出<code>vi</code>，这里也可以使用我编写的脚本<code>write_list.sh</code>，用法非常简单，看下脚本的内容应该也知道怎么用了，就不在这再说一遍了。运行<code>Shermo</code>，将<code>list.txt</code>载入，即可自动算出玻尔兹曼分布：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">$ Shermo list.txt<br>...<br>...<br>Low frequencies treatment: Harmonic approximation<br>Processing /home/visitor/research/simon/orca1.out... (    1  of    3 )<br>Processing /home/visitor/research/simon/orca2.out... (    2  of    3 )<br>Processing /home/visitor/research/simon/orca3.out... (    3  of    3 )<br><br><span class="hljs-comment">#System       U               H               G             S          CV</span><br>             a.u.            a.u.            a.u.        J/mol/K     J/mol/K<br>   1    -1969.815591    -1969.814647    -1969.948557    1179.203     783.166<br>   2    -1969.809359    -1969.808415    -1969.940882    1166.504     789.267<br>   3    -1969.809932    -1969.808988    -1969.937499    1131.665     781.476<br><br>System    1     Relative G=    0.000 kJ/mol     Boltzmann weight=  99.970 %<br>System    2     Relative G=   20.149 kJ/mol     Boltzmann weight=   0.030 %<br>System    3     Relative G=   29.033 kJ/mol     Boltzmann weight=   0.001 %<br><br>Conformation weighted data:<br>Electronic energy:     -1970.760257 a.u.<br>U:     -1969.815590 a.u.<br>H:     -1969.814645 a.u.<br>G:     -1969.948557 a.u.<br>S:      1179.222 J/mol/K    Conformation entropy:     0.023 J/mol/K<br>CV:      783.168 J/mol/K<br>CP:      791.483 J/mol/K<br></code></pre></td></tr></tbody></table></figure>
<p>另外可看参考文章：<a href="http://bbs.keinsci.com/thread-3805-1-1.html">频率校正因子</a>、<a href="http://sobereva.com/327">隐式溶剂模型和自由能计算</a></p>
<h2 id="计算激发态能量"><a href="#计算激发态能量" class="headerlink" title="计算激发态能量"></a>计算激发态能量</h2><p><code>ORCA</code> 使用 <code>TDDFT</code> 在 <code>RI-wB2GP-PLYP/def2-TZVP</code> 级别下计算激发态，还是使用<code>Multiwfn</code>生成输入文件，关键词为：</p>
<figure class="highlight llvm"><table><tbody><tr><td class="code"><pre><code class="hljs llvm">! PBE<span class="hljs-number">0</span> def<span class="hljs-number">2</span>-SV(P) def<span class="hljs-number">2</span>/J RIJCOSX CFLOAT grid<span class="hljs-number">4</span> gridx<span class="hljs-number">4</span> tightSCF noautostart miniprint nopop<br><span class="hljs-symbol">%maxcore</span>  <span class="hljs-number">1600</span><br><span class="hljs-symbol">%pal</span> nprocs <span class="hljs-number">36</span> <span class="hljs-keyword">end</span><br><span class="hljs-symbol">%cpcm</span><br>smd <span class="hljs-keyword">true</span><br>SMDsolvent <span class="hljs-string">"methanol"</span><br><span class="hljs-keyword">end</span><br><span class="hljs-symbol">%tddft</span><br>nroots <span class="hljs-number">30</span><br>TDA <span class="hljs-keyword">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>一般算30个states就够了，仅需要把<code>Multiwfn</code>生成的文件中的<code>nroots</code>改为30，然后运行<code>ORCA</code>，完成后得到<code>tddft1.out</code>。</p>
<h2 id="绘制平均光谱"><a href="#绘制平均光谱" class="headerlink" title="绘制平均光谱"></a>绘制平均光谱</h2><p>如果计算得到的能量最低的结构的玻尔兹曼分布占比很高，那么就不需要计算其他的构象了，反之则需要计算多个构象，再绘制其平均化之后的光谱，具体可参考<a href="http://sobereva.com/383">Multiwfn绘制平均光谱</a>。</p>
<p>启动<code>Multiwfn</code>，先绘制<code>UV-Vis</code>光谱，然后再绘制<code>ECD</code>光谱，并根据<code>UV-Vis</code>计算光谱和实际值的偏移量给<code>ECD</code>光谱加上同样的偏移量。</p>
<p>本文中使用的软件<code>Molclus</code>、<code>MOPAC</code>、<code>Multiwfn</code>、<code>Shermo</code>、<code>ORCA</code>均为免费软件，将其使用在自己的工作中一定需要引用对应的文献，如果你使用了我开发的小工具，别忘了在github上给我一个star😜</p>
<blockquote>
<p>Molclus引用文献：Tian Lu, molclus program, Version 1.9.6, <a href="http://www.keinsci.com/research/molclus.html">http://www.keinsci.com/research/molclus.html</a> (accessed Sep 2, 2020)</p>
</blockquote>
<blockquote>
<p>MOPAC2016引用文献：MOPAC2016, James J. P. Stewart, Stewart Computational Chemistry, Colorado Springs, CO, USA, HTTP://OpenMOPAC.net (2016).</p>
</blockquote>
<blockquote>
<p>Multiwfn引用文献：Tian Lu, Feiwu Chen, J. Comput. Chem., 33, 580-592 (2012).</p>
</blockquote>
<blockquote>
<p>Shermo引用文献：Tian Lu, Qinxue Chen, Shermo: A general code for calculating molecular thermodynamic properties, ChemRxiv (2020) DOI: 10.26434/chemrxiv.12278801</p>
</blockquote>
<blockquote>
<p>ORCA引用文献：WIREs Comput Mol Sci 2012, 2: 73–78 doi: 10.1002/wcms.81</p>
</blockquote>
]]></content>
      <categories>
        <category>计算化学</category>
      </categories>
  </entry>
  <entry>
    <title>在Discovery Studio中进行同源模建</title>
    <url>/ji-suan-hua-xue/homologymodeling-ds/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在药物设计中，如果目标蛋白质还没有被结晶出来，我们无法对其进行分子对接，但是，同源蛋白质三级结构的保守性远高于一级结构，因此可以通过已知三级结构的同源蛋白来模拟目标蛋白的空间结构，这就是同源模建技术。</p>
<p>商业软件如<code>Discovery Studio 2016</code>中集成了同源模建功能，我们可以通过操作图形界面很方便的使用。要进行同源模建，通常需要进行以下几个步骤：</p>
<ol>
<li>使用BLAST或PSI-BLAST查找模板。这是一种基于序列相似度的搜索算法。</li>
<li>使用结构对齐工具将找到的模板叠合在一起。</li>
<li>使用序列对齐工具将我们研究的蛋白模型的序列与模板序列对齐。</li>
<li>使用MODELER创建同源模型。</li>
</ol>
<p>在本例中，我们使用淀粉酶P41131演示。其序列可以点击<a href="http://www.uniprot.org/uniprot/P41131.fasta">这里下载</a>。</p>
<h1 id="查找模板"><a href="#查找模板" class="headerlink" title="查找模板"></a>查找模板</h1><p><font color="#FF0000">在菜单栏点击 <strong>File -&gt; Open</strong>，打开<code>p41131.fasta</code>，P41131的序列会显示在序列窗口中。</font></p>
<p>在序列比对算法中，BLAST是常用的方法。</p>
<p><font color="#FF0000">在<strong>Macromolecules</strong>选项卡中选择<strong>Search Sequences by Similarity -&gt; BLAST Search</strong></font></p>
<p>PDB和PDB_nr95数据库都可以检索，但最常用的是非冗余(non-redundant, nr)的PDB_nr95数据库。</p>
<p><font color="#FF0000">在弹出的BLAST对话框中选择<strong>Input Sequence</strong>为<code>P41131:P41131</code>，<strong>Input Database</strong>为<code>PDB_nr95</code></font></p>
<p>运行完后，关闭弹出的对话框，在右侧的Blast窗口可以看到检索到的模板，在下方的选项卡<strong>Table View</strong>中可以看到hits，每行都是一个序列；<strong>Map View</strong>中的bar的排序和Table View中是一一对应的，每条bar以评分高低着色，评分高的靠上，大于400的红色hits是最好的。</p>
<p><font color="#FF0000">按住shift键选中前五个最好的模板，右键单击并选择<strong>Load Structure and Alignment</strong></font></p>
<p>软件会自动从网站上下载蛋白质，然后将他们叠合在一起。如果想看二级结构，可以在菜单栏选择<font color="#FF0000"><strong>Sequence -&gt; Secondary Structure -&gt; Visibility</strong></font>，然后把<strong>Kabsch Sander</strong>和<strong>PDB</strong>都打勾，再点OK，下方序列窗口就会显示二级结构，蓝色的箭头是beta折叠，橙色的是alpha螺旋。</p>
<h1 id="对齐序列"><a href="#对齐序列" class="headerlink" title="对齐序列"></a>对齐序列</h1><p>要进行同源模建，我们首先需要将相同或相似度高的序列片段对齐，这样作出的模型才会最接近实验结果。要对齐序列，最好是先生成一个序列预设，然后将预设应用到叠合好的结构上，这种序列预设以包含最多同源结构为好。</p>
<p>接下来我们使用BLAST搜索Swiss-Prot数据库来创建序列预设。</p>
<p><font color="#FF0000">点击序列窗口的P41131(1)选项卡，展开<strong>Macromolecules -&gt; Create Homology Models</strong>，点击<strong>Align Sequence to Templates</strong></font></p>
<p>在弹出的对话框中设置：</p>
<p><font color="#FF0000"><strong>Input Model Sequence</strong>为<code>P41131-(1):P41131</code></font></p><font color="#FF0000">
<p><strong>Input Template Structures</strong>为<code>1G94A::All</code>（这样可以指定我们加载的全部5个结构）</p>
</font><p><font color="#FF0000"><strong>Create Sequence Profile</strong>为<code>Ture</code></font></p>
<p>若本地没有安装<strong>Swiss-Prot BLAST</strong>数据库，此时无法启动对齐作业，但软件为我们提供的在线搜索功能，可以展开<font color="#FF0000"><strong>Create Sequence Profile</strong>，将<strong>server</strong>改为<strong>NCBI</strong>，下一个选项选择swissprot，然后点击Run。</font>待软件执行完后，点击Report可以查看RMSD值。</p>
<h1 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h1><p>点击分子窗口中的1G94A(1)选项卡，使其处于活跃状态。</p>
<p><font color="#FF0000">点击<strong>Macromolecules -&gt; Create Homology Models -&gt; Build Homology Models</strong></font><br>在弹出的对话框中设置：</p>
<p><font color="#FF0000"><strong>Input Sequence Alignment</strong>为<code>P41131_templates:All</code></font></p><font color="#FF0000">
<p><strong>Input Template Structures</strong>中5个结构都被选中</p>
<p><strong>Input Model Sequence</strong>为<code>P41131</code></p>
<p><strong>Number of Models</strong>为<code>2</code></p>
</font><p><font color="#FF0000"><strong>Optimization Level</strong>为<code>Low</code></font></p>
<p>Optimization Level越高，模型越准确，但运行速度也越慢。建模完成后，点击Report，在右侧会出现报告，结果以<strong>PDF Total Energy</strong>排序，能量越低越好，如果能量相差很小，可以看最右侧的DOPE得分，同样的越低越好。</p>
<p>最佳的模型会自动被显示在分子窗口中，此时你可以检查一下这个结构。</p>
<p><font color="#FF0000">在分子窗口下方点击<strong>AminoAcid</strong>选项卡，然后把滚动条拉到最右边，可以看到<strong>PDF Total</strong>的那一列，选中这一列，在菜单栏选择<strong>Chart -&gt; Line Plot</strong></font></p>
<p>这时右侧会出现一个曲线图，这个图里的Peak是需要注意的，鼠标左键画圈选中以后，下方序列窗口里相应的氨基酸残基会被高亮显示，检查一下有无异样。</p>
<h1 id="结构评估"><a href="#结构评估" class="headerlink" title="结构评估"></a>结构评估</h1><p>DS中提供了一个评估结构的工具，它可以评价蛋白模型的三级结构与其序列的相容性。</p>
<p><font color="#FF0000">按Ctrl + H打开分类视图，选择P41131.M0001分子，然后点击<strong>Macromolecules -&gt; Create Homology Models -&gt; Verify Protein (Profiles-3D)</strong></font></p><font color="#FF0000">
</font><p><font color="#FF0000">在弹出的对话框中<strong>Input Protein Molecules</strong>设定为<strong>P41131:Selected</strong>，点Run启动分析</font></p>
<p>运行结束后在弹出的对话框中点击Report，分析结果会被添加到AminoAcid选项卡中。现在分子窗口的蛋白模型会被重新着色，蓝色表示高分，白色表示中等，红色得分较低。在这里，得分越高越好。接下来可以在AminoAcid选项卡中找到Verify Score列，然后按之前提到过的方法创建曲线图，检查得分低的地方的氨基酸残基有无异样。</p>
<p>到这里就完成了DS中同源模型的创建与检查工作。</p>
]]></content>
      <categories>
        <category>计算化学</category>
      </categories>
  </entry>
  <entry>
    <title>Homology Modeling——同源模建简介</title>
    <url>/ji-suan-hua-xue/homologymodeling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>同源模建是药物研发中的一种常用方法。对一个靶点进行研究，通常需要得到它的单晶，并用X-射线衍射测出其三维结构，之后我们便可以在计算机中使用软件针对其开展诸如分子对接、动力学模拟等一系列工作。然而，有的蛋白含量低，纯化困难，有的不易结晶，使得我们有时拿不到目标蛋白的结构。不过，幸运的是，对大量蛋白进行研究之后，人们发现同源蛋白中存在着相同的折叠方式，即便是一级结构相似度只有20%左右的同源蛋白，他们的空间结构也有不少重合之处，这就为用已知结构的蛋白预测目标蛋白结构的方法提供了理论基础<a href="#ref-1"><sup>1</sup></a>。更加深入的研究发现，蛋白的氨基酸数量越多，对序列相似度的要求就越低。例如，在一个有60个氨基酸等蛋白中，只需要有30%的序列相同，就可进行“安全”的同源模建；而若氨基酸数量是30个，就要求大于40%的相似度<a href="#ref-2"><sup>2</sup></a>。</p>
<h1 id="同源模建基本流程"><a href="#同源模建基本流程" class="headerlink" title="同源模建基本流程"></a>同源模建基本流程</h1><p>现在要进行同源模建工作可以说是很方便的，有许多免费的工具可以使用，例如在线的<code>SWISS-MODEL</code>，只要提交了氨基酸序列就能返回建模结果；在本地运行的程序例如<code>WHAT IF</code>和<code>MODELLER</code>，它们都是免费的，其中<code>MODELLER</code>的商业版本由<code>BIOVIA</code>公司运营，整合在<code>Discovery Studio</code>中并提供了图形化界面。尽管软件各式各样，但是同源模建大体上可以概括为以下四个步骤：查找模板、对齐序列、建模、模型优化与验证。</p>
<h2 id="查找模板"><a href="#查找模板" class="headerlink" title="查找模板"></a>查找模板</h2><p>自20世纪以来，得益于各种测定技术的发展，人们开始掌握了越来越多的生物大分子的空间结构。1968年，人们开发出了在计算机上显示蛋白质的程序，由此，便催生出了<code>PDB</code>（Protein Data Bank）数据库，它是目前唯一收载了生物大分子三维结构信息的数据库，其中主要是蛋白质，也有少量的核酸。PDB创建的早期阶段，人们为了搜索结构会去比对整个序列，这在当时数据量少的时候倒也行得通，然而截至目前，PDB共收载了132900余个条目，即便是以今天的计算机算力，全序列比对仍然是一项庞大费事的任务。于是为了解决这个问题，David J. Lipman和William R. Pearson在1985年开发了<code>FASTP</code>算法<a href="#ref-3"><sup>3</sup></a>，后来又演变成<code>FASTA</code>，意为”Fast-All”，表明了其快速性与通用性，对蛋白质和核酸都适用。1990年，Altschul等人开发了比FASTA更快一些的<code>BLAST</code> (Basic Local Alignment Search Tool)方法<a href="#ref-4"><sup>4</sup></a>，在今天的研究中有着广泛的应用。BLAST利用20种氨基酸制作了一个20*20的得分矩阵，如图所示，对角线上匹配的氨基酸得分最高。</p>
<img src="https://tvax4.sinaimg.cn/large/005Vgpymly1gjv1m1k0q3j30s00j4qfe.jpg" title="一种得分矩阵" width="50%" height="50%">

<p>然后将我们查询的序列分成若干等长的字段，配合得分矩阵进行评分，并经过一系列评价后找到所求序列。</p>
<h2 id="对齐序列"><a href="#对齐序列" class="headerlink" title="对齐序列"></a>对齐序列</h2><p>前面查找序列时所用的<code>BLAST</code>其实就可以对齐序列，我们称其为“简单序列对齐程序”，它在查找的过程中能顺便对齐一下序列。然而对于某些蛋白来说，尽管他们是同源的，但是由于某些区域的序列差异使得<code>BLAST</code>无法对齐，这时就需要用到“多重序列对齐(MSA)”程序，该程序可以进行一定同源性推导，而帮助我们进行对齐。</p>
<p>在建模时我们自然希望模板链和目标链重合的越多越好，那样我们的模型就越可靠，但是事情并不总是我们期待的那样。设想一下这种情况：我们的模板链由100个氨基酸残基，通过查询，有3条蛋白链分别有一部分与未知链重合，那么最好的情况就是我们把这最好的三个部分分别作为目标链对应区域的模板。MSA可以生成一种称为“序列谱”（profile）的东西<a href="#ref-5"><sup>5</sup></a>，也被称为“位置特异性得分矩阵”，它可以在搜索时匹配到更多的模板，在建模时把最佳的模板赋给目标链，保证保守区域不会发生变化。</p>
<p>在Discovery Studio中，同源模建时查询的数据库都是非冗余数据库。例如查找模板时查询的不是PDB数据库，而是<code>PDB_nr95</code>数据库（nr即non-redundant），多重序列对齐时查询的是<code>SWISS-Prot</code>数据库，这些数据库都经过人工审查，没有重复数据，能节省查询时间，同时它们中的数据还经过人工校对，可以使建模效果更好。</p>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>序列对齐好后，我们的建模工作就可以开始了。同源模建工作发展到现在已经实现了自动化，执行这一步只需要点几下鼠标，但是其内部的工作过程其实可以分成三步：<strong>生成主链（Backbone）、生成回环（Loop）、生成侧链（Side-Chain）</strong>。</p>
<p>在主链建模时，只需要简单地把对齐好的模版链片段的坐标赋给目标链。与多重序列对齐相同，主链建模时使用一种叫“多模板建模”的思想，即将各个模版中的最优部分作为模型赋给目标链。对于蛋白上的保守区域，同源蛋白间的序列一致度很高，侧链构象也倾向于保守，因此可以把这些氨基酸残基上携带的侧链一并复制到目标链中，这种直接复制坐标的方法被称作“刚体装配法”。还有一种方法是“空间限制法”，它根据几何和约束关系进行建模，使模型满足空间限制，<code>MODELLER</code>就是使用这种方法。</p>
<p>Loop区的建模一直是同源模建工作的难点，原因在于Loop区不保守，有着很大的变动性，准确预测其结构较为困难。目前对Loop区进行建模主要有两种方法：基于现有知识的数据库查询和基于能量的构象搜索。查询数据库虽然简单快捷，但是由于数据不完整，能不能找到好模板还是要看运气，并且随着Loop的增长，匹配难度也越发增加。因此对于Loop区的预测主要还是应用能量计算，对于5-8个氨基酸残基的Loop，已经能给出比较准确的预测，例如蒙特卡洛方法<a href="#ref-6"><sup>6</sup></a>、模拟退火<a href="#ref-7"><sup>7</sup></a>等。近年来新发展了一些构象搜索方法<a href="#ref-8"><sup>8</sup></a>，使得通过计算得到的模型越来越精准，10-12个氨基酸残基的Loop的预测准确度有了较大的改善。</p>
<p>当主链构象固定后，保守区的侧链氨基酸残基可以直接复制到模型中，因此侧链建模准确的前提是主链构象准确。基本上所有的侧链建模都会依赖于片段搜索，因为利用实验手段测出的结构都符合能量约束，构建侧链时先从未知特异性旋转异构体库中搜索相似构象，然后使用能量约束进行优化。</p>
<h2 id="优化与验证"><a href="#优化与验证" class="headerlink" title="优化与验证"></a>优化与验证</h2><p>对整个蛋白质进行构象扫描来优化，即使是以今天的计算机水平也是几乎不可能完成的任务，而侧链建模依赖于主链，主链又会受到侧链影响，这似乎陷入了一个死循环。为了解决模型的优化问题，一种方法是先使用已有的主链预测一次侧链，然后根据侧链的空间与能量关系对主链进行调整，如此反复，直至结果自洽。使用这种方法进行预测，能量方程越精确，模型质量自然也就越高，即使是最直接的分子动力学模拟也是有赖于力场数据。在Discovery Studio中，模型的优化与验证都是依靠自由能数据的，但是仅仅能量低并不够，在有些情况下，错误折叠的蛋白质会带来比正确结构更加稳定的能量，因此，在进行同源模建工作时，每一步都应当考虑如何能够最少地引入错误，才能使我们的模型更佳具有实用性。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="ref-1">1. C. Chothial, A. M.Lesk, “The relation between the divergence of sequence and structure in proteins”. EMBO J. (1986) Vol.5: 823-836.</div>
<div id="ref-2">2. Sander C, Schneider R, “Database of homology-derived protein structures and the structural meaning of sequence alignment”. Proteins (1991). Vol.9: 56–68.</div>
<div id="ref-3">3. Lipman, DJ; Pearson, WR. "Rapid and sensitive protein similarity searches". Science (1985). 227 (4693): 1435–1341.</div>
<div id="ref-4">4. Altschul SF. “Basic local alignment search tool.” J Mol Biol. (1990 Oct 5);215(3): 403-410.</div>
<div id="ref-5">5. Taylor WR. “Identification of protein sequence homology by consensus template alignment.” J Mol Biol. (1986 Mar 20); 188(2):233-258.</div>
<div id="ref-6">6. Hansmann UH. “ew Monte Carlo algorithms for protein folding.” Curr Opin Struct Biol. 1999 Apr;9(2):177-183.</div>
<div id="ref-7">7. Kim T. Simons. “Assembly of Protein Tertiary Structures from Fragments with Similar Local Sequences using Simulated Annealing and Bayesian Scoring Functions” J. Mol. Biol. (1997) 268, 209-225</div>
<div id="ref-8">8. 袁飞. “基于氨基酸位置特异性的蛋白质Loop区结构预测” Acta Phys. Sin. Vol. 65, No. 15 (2016) 158701</div>
]]></content>
      <categories>
        <category>计算化学</category>
      </categories>
  </entry>
  <entry>
    <title>在MacOS上编译OSRA（光学结构识别程序）</title>
    <url>/sui-bi/compile-osra-on-mac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>绘制结构是化学工作者的基本功，但是对于大数据相关的工作，人工绘制数十万个结构就有些不现实，所以如果能实现类似OCR的功能，将对机器学习有很大帮助。2008年，一个叫Igor V. Filippov的老哥发布了名为OSRA的程序，即Optical Structure Recognition Application(光学结构识别程序）。这是一种类似于传统的OCR式程序，能将图片中的化学结构式转换成计算机可以读取的格式如SMILES、SDF等，它后来Schrödinger公司做的那种基于神经网络的结构识别系统有本质区别。第二年，老哥把工作写成了论文，如果想详细了解，可以看这篇文章：<a href="https://pubs.acs.org/doi/abs/10.1021/ci800067r"><em>J. Chem. Inf. Model.</em> 2009, 49, 3, 740–743</a>。</p>
<p>这个程序的编译并不怎么顺利，遇到了挺多坑的，我是好几年前知道它的存在的，但是由于一直没时间排坑，就总在用它的<a href="https://cactus.nci.nih.gov/cgi-bin/osra/index.cgi">在线版</a>，但是长久以来在线版都没办法导出SDF，而SMILES的转换又没法跟图片上一致，而且最要命的是，它的图像API居然完全无法识别MacOS下生成的图片！！所以还是得编译本地版。这段时间由于肺炎疫情一直在家呆着，终于有时间仔细研究一下了。（果然闲出屁可以作出奇怪的工作2333）</p>
<p>本文的编译环境为MacOS 10.13.6，没有在其他系统上使过，并不推荐Windows系统，似乎挺麻烦的，作者也不推荐。首先，电脑上需要安装<a href="https://subversion.apache.org/download.cgi#recommended-release">subversion</a>和<a href="https://brew.sh/">homebrew</a>，subversion用来下载源代码，homebrew则用来安装依赖。</p>
<p>不知道出于什么原因，作者只会把BUG修复到svn版的代码里（可能是懒癌？），所以先用svn把代码check出来：</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># must use svn version code</span><br>svn checkout https:<span class="hljs-regexp">//</span>svn.code.sf.net<span class="hljs-regexp">/p/</span>osra<span class="hljs-regexp">/code/</span>tags/<span class="hljs-number">2.1</span>.<span class="hljs-number">1</span> osra-code<br></code></pre></td></tr></tbody></table></figure>
<p>然后安装依赖，有一些是可以直接用brew安装的，有一些还是需要编译安装，先说brew安装的：</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>libiconv, zlib, <span class="hljs-keyword">bzip2, </span>freetype, libpng, libtiff, lcms, <span class="hljs-keyword">jasper, </span>libjpeg<br></code></pre></td></tr></tbody></table></figure>
<p>下面的一些依赖需要编译安装，用户要去对应的库的官网下载代码，然后按照如下的命令逐个安装：</p>
<figure class="highlight gauss"><table><tbody><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#libxml2</span><br>./autogen.sh<br><span class="hljs-built_in">make</span> -j4<br>sudo <span class="hljs-built_in">make</span> install<br><br><span class="hljs-meta">#Compile OCRAD and TCLAP as follows:</span><br>./configure<br><span class="hljs-built_in">make</span> -j4<br>sudo <span class="hljs-built_in">make</span> install<br><br><span class="hljs-meta">#Potrace:</span><br>./configure --with-libpotrace --<span class="hljs-keyword">disable</span>-shared<br><span class="hljs-built_in">make</span> -j4<br>sudo <span class="hljs-built_in">make</span> install<br><br><span class="hljs-meta">#GOCR:</span><br>./configure<br><span class="hljs-built_in">make</span> libs<br>sudo <span class="hljs-built_in">make</span> install<br><br></code></pre></td></tr></tbody></table></figure>
<p>注意这里，Openbabel需要使用作者patch过的版本，可以在<a href="https://sourceforge.net/projects/osra/files/openbabel-patched/openbabel-3-0-0-patched.tgz/download">他的sourceforge</a>下载到，下载完成后按如下命令安装：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#Openbabel</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LDFLAGS</span>=/usr/local/opt/libiconv/lib/libiconv.a<br>mkdir build<br>cd build<br>cmake <span class="hljs-attribute">-DBUILD_SHARED</span>=OFF <span class="hljs-built_in">..</span><br>sudo make install<br><br><span class="hljs-comment">#GraphicsMagick</span><br><span class="hljs-builtin-name">export</span> LDFLAGS=<br>./configure --disable-shared <span class="hljs-attribute">--with-x</span>=<span class="hljs-literal">no</span> --disable-openmp --without-threads<br>make -j4<br>sudo make install<br><span class="hljs-comment"># 要保证你的PATH里可以找到graphicsmagick++-config</span><br><span class="hljs-comment"># 把下面的路径换成你自己存储GraphicsMagick源代码的位置</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=/Users/simon/Downloads/GraphicsMagick-1.3.21/Magick++/bin:$PATH<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=/usr/local/lib<br><br><span class="hljs-comment">#Poppler</span><br>sudo chown -R $(whoami) /usr/local/share/man/man4<br>brew install pkgconfig openjpeg<br>mkdir build<br>cd build<br>cmake <span class="hljs-attribute">-DCMAKE_BUILD_TYPE</span>=Release <span class="hljs-attribute">-DCMAKE_INSTALL_PREFIX</span>=/usr/local <span class="hljs-attribute">-DENABLE_UNSTABLE_API_ABI_HEADERS</span>=ON <span class="hljs-built_in">..</span><br>make -j4<br>sudo make install<br></code></pre></td></tr></tbody></table></figure>
<p>到这里依赖就全部安装好了，然后就是编译OSRA主程序了。你遇到的第一个大坑就是<code>configure</code>文件。作者原始的文件应该是没对mac优化过，所以configure就过不了，得手动把里面的某些参数改一改。用文本编辑器打开<code>configure</code>，找到所有的<code>-static-libgcc</code>，把它们全都删掉。然后搜索<code>${MACPORTLIBS}</code>，然后把这个变量替换成相应位置显示的库文件，你安装的库版本可能会和我的不一样，所以你需要确认一下你电脑上安装的真实版本，然后把路径改成你的，挨个替换。通过HomeBrew安装的库文件会在<code>/usr/local/Cellar/</code>里，而编译安装的库则在<code>/usr/local/lib/</code>里。有以下几个库需要替换：</p>
<figure class="highlight crystal"><table><tbody><tr><td class="code"><pre><code class="hljs crystal">/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libxml2</span>.<span class="hljs-title">a</span> </span><br>/usr/local/Cellar/libiconv/<span class="hljs-number">1.16</span>/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libiconv</span>.<span class="hljs-title">a</span> </span><br>/usr/local/Cellar/zlib/<span class="hljs-number">1.2</span>.<span class="hljs-number">11</span>/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libz</span>.<span class="hljs-title">a</span></span><br>/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">liblcms2</span>.<span class="hljs-title">a</span> </span><br>/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libtiff</span>.<span class="hljs-title">a</span> </span><br>/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libfreetype</span>.<span class="hljs-title">a</span> </span><br>/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libjasper</span>.<span class="hljs-title">a</span> </span><br>/usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libpng</span>.<span class="hljs-title">a</span> </span><br>/usr/local/Cellar/bzip2/<span class="hljs-number">1.0</span>.<span class="hljs-number">8</span>/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libbz2</span>.<span class="hljs-title">a</span> </span><br>/usr/local/Cellar/zlib/<span class="hljs-number">1.2</span>.<span class="hljs-number">11</span>/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libz</span>.<span class="hljs-title">a</span></span><br></code></pre></td></tr></tbody></table></figure>
<p>完成后，再运行<code>configure</code>就可以通过了，然后按照前面一样的方法make再install就可以了：</p>
<figure class="highlight gradle"><table><tbody><tr><td class="code"><pre><code class="hljs gradle">.<span class="hljs-regexp">/configure --enable-static-linking --with-graphicsmagick-lib=/u</span>sr<span class="hljs-regexp">/local/</span>lib --with-graphicsmagick-<span class="hljs-keyword">include</span>=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/include/G</span>raphicsMagick<br><br>make -j4<br>sudo make install<br></code></pre></td></tr></tbody></table></figure>

<hr>
<center><b><font color="#FF0000">以下是我的私货时间</font></b>（笑）</center>

<hr>
<p>化学专业的学生写毕业论文综述要画上好几百个结构，手动画太令人头大了，有了OSRA后，就可以直接识别PDF里的结构了，于是乎我写了一个截图的GUI小程序，直接在结构上画个框就能把图截下来，然后自动调用OSRA把结构识别成SDF格式，PNG和SDF会被分别保存下来，SDF打开以后套一个模板就可以复制到word里去用了。</p>
<p>程序源代码我发布在了<a href="https://github.com/SSSSSimon/OSRA-screenshot-GUI">我的github</a>上，用python写成，需要先用pip安装PyQt5，如果对你有帮助，别忘了在github上给我一个star😋下方是一个演示视频～</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/images/osra-demo.mov","pic":"/images/osra-demo.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>ffmpeg合并视频</title>
    <url>/sui-bi/ffmpeg-he-bing-shi-pin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>优酷的反下载策略更新了，youtube-dl已经下载不到里面的视频了，所以只能手动从chrome里把视频地址提取出来手动下载，这样一个2分多钟的视频就下载了16个文件，都是flv格式：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">MycBook:Downloads simon$ l<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (1).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (10).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (11).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (12).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (13).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (14).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (15).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (16).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (2).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (3).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (4).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (5).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (6).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (7).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (8).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv (9).flv<br>0300020100548835AD4062058613CA43CA43F2-212A-79CF-E8FC-7AFA17047A31.flv.flv<br><br></code></pre></td></tr></tbody></table></figure>
<p>将它们重命名一下，写一个shell循环：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.flv<br><span class="hljs-keyword">do</span><br>name=<span class="hljs-variable">${file%)*}</span><br>name=<span class="hljs-variable">${name#*(}</span><br>mv <span class="hljs-string">"<span class="hljs-variable">${file}</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${name}</span>.flv"</span><br><span class="hljs-keyword">done</span><br>mv 0* 0.flv<br></code></pre></td></tr></tbody></table></figure>

<p>这样文件就变得有序了，接下来写一个文本文件，把这些文件名都放进去，以便ffmpeg查找：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> {0..16}<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"file '<span class="hljs-variable">${file}</span>.flv'"</span> &gt;&gt; filelist.txt<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></tbody></table></figure>

<p>然后我们就有了这样一个文件：</p>
<img src="https://tva3.sinaimg.cn/large/005Vgpymly1gjv1m0a3w2j303b07iq2w.jpg" title="filelist.txt">

<p>接下来输入合成命令：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -f concat -i filelist.txt -c copy output.mp4<br></code></pre></td></tr></tbody></table></figure>

<p>搞定！</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">MycBook:Downloads simon$ ll<br>-rw-r--r--@  1 simon  staff         201912 10 19 23:12 0.flv<br>-rw-r--r--@  1 simon  staff         331256 10 19 23:12 1.flv<br>-rw-r--r--@  1 simon  staff         337272 10 19 23:12 10.flv<br>-rw-r--r--@  1 simon  staff         448568 10 19 23:12 11.flv<br>-rw-r--r--@  1 simon  staff         475640 10 19 23:12 12.flv<br>-rw-r--r--@  1 simon  staff         346296 10 19 23:12 13.flv<br>-rw-r--r--@  1 simon  staff         607992 10 19 23:12 14.flv<br>-rw-r--r--@  1 simon  staff         466616 10 19 23:13 15.flv<br>-rw-r--r--@  1 simon  staff         126712 10 19 23:13 16.flv<br>-rw-r--r--@  1 simon  staff         358328 10 19 23:12 2.flv<br>-rw-r--r--@  1 simon  staff         412472 10 19 23:12 3.flv<br>-rw-r--r--@  1 simon  staff         403448 10 19 23:12 4.flv<br>-rw-r--r--@  1 simon  staff         376376 10 19 23:12 5.flv<br>-rw-r--r--@  1 simon  staff         370360 10 19 23:12 6.flv<br>-rw-r--r--@  1 simon  staff         361336 10 19 23:12 7.flv<br>-rw-r--r--@  1 simon  staff         400440 10 19 23:12 8.flv<br>-rw-r--r--@  1 simon  staff         427512 10 19 23:12 9.flv<br>-rw-r--r--@  1 simon  staff        6073530 10 19 23:47 output.mp4<br></code></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>ffmpeg视频压制</title>
    <url>/sui-bi/ffmpeg-shi-pin-ya-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分辨率可以自己定义，把对于的参数改成自己需要的就好了。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -i video.mov -vcodec libx264 -preset veryslow -profile:v high -level:v 5.2 -x264-params keyint=270:min-keyint=29.97 -pix_fmt yuv420p -b:v 2000k -s 1920x1080 -r 29.97 -pass 1 -an -f mp4 -y NUL &amp;&amp; ffmpeg -i video.mov -vcodec libx264 -preset veryslow -profile:v high -level:v 5.2 -x264-params keyint=270:min-keyint=29.97 -pix_fmt yuv420p -b:v 2000k -s 1920x1080 -r 29.97 -pass 2 -c:a copy video.mp4<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>pv+dd写入硬盘镜像</title>
    <url>/sui-bi/pv-dd-xie-ru-ying-pan-jing-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight gradle"><table><tbody><tr><td class="code"><pre><code class="hljs gradle">sudo pv -cN <span class="hljs-keyword">source</span> &lt; <span class="hljs-keyword">file</span>.iso | sudo dd of=<span class="hljs-regexp">/dev/</span>rdisk2 bs=<span class="hljs-number">4</span>m<br></code></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>为openwrt腾讯云DDNS插件增加IPv6支持</title>
    <url>/sui-bi/tencentddnsv6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>腾讯云为Openwrt开发了一个官方的DDNS插件，但是该插件只支持更新IPv4地址，鉴于现在国内基本都实现了IPv6覆盖，其实只要把DDNS的IPv6支持打开，就不必总去向运营商要IPv4地址了。</p>
<p>可以直接去<a href="https://github.com/SSSSSimon/tencentcloud-openwrt-plugin-ddns">我的github仓库</a>拿到改好的源码和ipk包，仅在此记录一下更新过程。</p>
<hr>
<p>首先把腾讯官方的插件源代码下载到本地：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/Tencent-Cloud-Plugins/tencentcloud-openwrt-plugin-ddns.git<br></code></pre></td></tr></tbody></table></figure>
<p>cd进源代码目录，可以先观察一下源代码的结构：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><code class="hljs css">➜  <span class="hljs-selector-tag">tencentcloud-openwrt-plugin-ddns</span> <span class="hljs-selector-tag">git</span><span class="hljs-selector-pseudo">:(master)</span> <span class="hljs-selector-tag">tree</span><br>.<br>├── <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span><br>├── <span class="hljs-selector-tag">images</span><br>│&nbsp;&nbsp; ├── <span class="hljs-selector-tag">ddns1</span><span class="hljs-selector-class">.png</span><br>│&nbsp;&nbsp; ├── <span class="hljs-selector-tag">ddns2</span><span class="hljs-selector-class">.png</span><br>│&nbsp;&nbsp; └── <span class="hljs-selector-tag">qrcode</span><span class="hljs-selector-class">.png</span><br>└── <span class="hljs-selector-tag">tencentcloud_ddns</span><br>    ├── <span class="hljs-selector-tag">LICENSE</span><br>    ├── <span class="hljs-selector-tag">Makefile</span><br>    ├── <span class="hljs-selector-tag">files</span><br>    │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">luci</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">controller</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── <span class="hljs-selector-tag">tencentddns</span><span class="hljs-selector-class">.lua</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">i18n</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── <span class="hljs-selector-tag">tencentddns</span><span class="hljs-selector-class">.zh-cn</span><span class="hljs-selector-class">.po</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp; └── <span class="hljs-selector-tag">model</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp;     └── <span class="hljs-selector-tag">cbi</span><br>    │&nbsp;&nbsp; │&nbsp;&nbsp;         └── <span class="hljs-selector-tag">tencentddns</span><span class="hljs-selector-class">.lua</span><br>    │&nbsp;&nbsp; └── <span class="hljs-selector-tag">root</span><br>    │&nbsp;&nbsp;     ├── <span class="hljs-selector-tag">etc</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">config</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── <span class="hljs-selector-tag">tencentddns</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">init</span><span class="hljs-selector-class">.d</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── <span class="hljs-selector-tag">tencentddns</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; ├── <span class="hljs-selector-tag">tencentddnsupload</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp; └── <span class="hljs-selector-tag">uci-defaults</span><br>    │&nbsp;&nbsp;     │&nbsp;&nbsp;     └── <span class="hljs-selector-tag">luci-tencentddns</span><br>    │&nbsp;&nbsp;     └── <span class="hljs-selector-tag">usr</span><br>    │&nbsp;&nbsp;         └── <span class="hljs-selector-tag">sbin</span><br>    │&nbsp;&nbsp;             └── <span class="hljs-selector-tag">tencentddns</span><br>    └── <span class="hljs-selector-tag">tools</span><br>        └── <span class="hljs-selector-tag">po2lmo</span><br>            ├── <span class="hljs-selector-tag">Makefile</span><br>            └── <span class="hljs-selector-tag">src</span><br>                ├── <span class="hljs-selector-tag">po2lmo</span><span class="hljs-selector-class">.c</span><br>                ├── <span class="hljs-selector-tag">template_lmo</span><span class="hljs-selector-class">.c</span><br>                └── <span class="hljs-selector-tag">template_lmo</span><span class="hljs-selector-class">.h</span><br><br>18 <span class="hljs-selector-tag">directories</span>, 18 <span class="hljs-selector-tag">files</span><br></code></pre></td></tr></tbody></table></figure>

<p><code>files/luci/</code>下放着的都是与web界面相关的配置文件，其中<code>controller/</code>下放的文件用来控制web管理界面的入口；<code>i18n/</code>下放的文件用来控制显示语言；而<code>model/cbi/</code>则用来写入配置文件并实现软件包逻辑。<code>files/root/</code>下是一些脚本文件，用来实现具体的软件功能，例如<code>etc/</code>目录下是与配置、服务、参数默认值等相关的脚本；<code>usr/sbin/</code>下是该软件包的可执行文件，这个DDNS包的核心功能都是由这个文件实现的。</p>
<p>我个人比较偏好于把这个插件的luci入口放在<code>服务</code>菜单下，因此需要修改<code>files/luci/controller/tencentddns.lua</code>文件，直接全部复制粘贴替换即可：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">module</span>(<span class="hljs-string">"luci.controller.tencentddns"</span>,<span class="hljs-built_in">package</span>.<span class="hljs-built_in">seeall</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span><br>entry({<span class="hljs-string">"admin"</span>, <span class="hljs-string">"services"</span>}, firstchild(), <span class="hljs-string">"Services"</span>, <span class="hljs-number">30</span>).dependent=<span class="hljs-literal">false</span><br>entry({<span class="hljs-string">"admin"</span>, <span class="hljs-string">"services"</span>, <span class="hljs-string">"tencentddns"</span>},cbi(<span class="hljs-string">"tencentddns"</span>),_(<span class="hljs-string">"TencentDDNS"</span>),<span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>IPv6地址其实需要在<code>lan</code>口的连接信息中找到，<code>wan</code>口获得的地址是光猫分配的一个内网地址，原始插件也没有提供<code>wan_6</code>的选项，因此找到<code>files/luci/model/cbi/tencentddns.lua</code>文件，在第26行增加一个选项<code>iface:value("lan")</code>：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><code class="hljs lua">iface:value(<span class="hljs-string">""</span>,translate(<span class="hljs-string">"Select WAN-IP Source"</span>))<br>iface:value(<span class="hljs-string">"internet"</span>)<br>iface:value(<span class="hljs-string">"wan"</span>)<br>iface:value(<span class="hljs-string">"lan"</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>接下来为插件的web界面增加一个IPv6的控制选项，在第13行下面加入如下代码：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><code class="hljs lua">enable=e:option(Flag,<span class="hljs-string">"ipv6"</span>,translate(<span class="hljs-string">"ipv6"</span>),translate(<span class="hljs-string">"ipv6 mean"</span>))<br>enable.rmempty=<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure>

<p>然后修改<code>files/luci/i18n/tencentddns.zh-cn.po</code>，在第15行下面加入下列代码，给选项加上对应的字符串解释：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">msgid</span> <span class="hljs-string">"ipv6"</span><br>msgstr <span class="hljs-string">"更新IPv6地址"</span><br><br>msgid <span class="hljs-string">"ipv6 mean"</span><br>msgstr <span class="hljs-string">"如果勾选，仅更新IPv6地址"</span><br></code></pre></td></tr></tbody></table></figure>

<p>然后修改可执行文件脚本，即<code>files/root/usr/sbin/tencentddns</code>文件，在其中新增一些用于控制IPv6相关更新的函数：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-function"><span class="hljs-title">resolve2ipv6</span></span>() {<br>	<span class="hljs-comment"># resolve2ip domain&lt;string&gt;</span><br>	domain=<span class="hljs-variable">$1</span><br>	tmp_ip=`nslookup    <span class="hljs-variable">$domain</span> f1g1ns1.dnspod.net 2&gt;/dev/null | sed <span class="hljs-string">'/^Server/d; /#53$/d'</span> | grep -oE <span class="hljs-string">'[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}::[1]'</span> | tail -n1`<br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$tmp_ip</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		tmp_ip=`nslookup <span class="hljs-variable">$domain</span> f1g1ns2.dnspod.net  2&gt;/dev/null | sed <span class="hljs-string">'/^Server/d; /#53$/d'</span> | grep -oE <span class="hljs-string">'[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}::[1]'</span> | tail -n1`<br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$tmp_ip</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		tmp_ip=`nslookup <span class="hljs-variable">$domain</span> 114.114.115.115 2&gt;/dev/null | sed <span class="hljs-string">'/^Server/d; /#53$/d'</span> | grep -oE <span class="hljs-string">'[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}::[1]'</span> | tail -n1`<br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$tmp_ip</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		tmp_ip=`curl -sL --connect-timeout 3 <span class="hljs-string">"119.29.29.29/d?dn=<span class="hljs-variable">$domain</span>"</span>`<br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-built_in">echo</span> -n <span class="hljs-variable">$tmp_ip</span><br>}<br><br><span class="hljs-function"><span class="hljs-title">check_tencentddnsv6</span></span>() {<br>	<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> WAN-IP: <span class="hljs-variable">${ip}</span>"</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$ip</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> ERROR, cant get WAN-IP..."</span><br>		<span class="hljs-built_in">return</span> 0<br>	<span class="hljs-keyword">fi</span><br>	current_ip=$(resolve2ipv6 <span class="hljs-string">"<span class="hljs-variable">$sub_dm</span>.<span class="hljs-variable">$main_dm</span>"</span>)<br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$current_ip</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		rrid=<span class="hljs-string">''</span> <span class="hljs-comment"># NO Resolve IP Means new Record_ID</span><br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> DOMAIN-IP: <span class="hljs-variable">${current_ip}</span>"</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$ip</span>"</span> == <span class="hljs-string">"Z<span class="hljs-variable">$current_ip</span>"</span> ]; <span class="hljs-keyword">then</span><br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> IP dont need UPDATE..."</span><br>		<span class="hljs-built_in">return</span> 0<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> UPDATING..."</span><br>		<span class="hljs-built_in">return</span> 1<br>	<span class="hljs-keyword">fi</span><br>}<br><br><span class="hljs-function"><span class="hljs-title">query_recordidv6</span></span>() {<br>        send_request <span class="hljs-string">"Record.List"</span> <span class="hljs-string">"domain=<span class="hljs-variable">$main_dm</span>&amp;sub_domain=<span class="hljs-variable">$sub_dm</span>&amp;record_type=AAAA"</span><br>}<br><br><span class="hljs-function"><span class="hljs-title">update_recordv6</span></span>() {<br>        send_request <span class="hljs-string">"Record.Modify"</span> <span class="hljs-string">"domain=<span class="hljs-variable">$main_dm</span>&amp;sub_domain=<span class="hljs-variable">$sub_dm</span>&amp;record_id=<span class="hljs-variable">$1</span>&amp;record_type=AAAA&amp;record_line=%e9%bb%98%e8%ae%a4&amp;value=<span class="hljs-variable">$ip</span>"</span><br>}<br><br><span class="hljs-function"><span class="hljs-title">add_recordv6</span></span>() {<br>        send_request <span class="hljs-string">"Record.Create"</span> <span class="hljs-string">"domain=<span class="hljs-variable">$main_dm</span>&amp;sub_domain=<span class="hljs-variable">$sub_dm</span>&amp;record_type=AAAA&amp;record_line=%e9%bb%98%e8%ae%a4&amp;value=<span class="hljs-variable">$ip</span>"</span><br>}<br><br><span class="hljs-function"><span class="hljs-title">do_ddns_recordv6</span></span>() {<br>	<span class="hljs-keyword">if</span> uci_bool_by_name base clean ; <span class="hljs-keyword">then</span><br>		query_recordidv6 | get_recordid | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> rr; <span class="hljs-keyword">do</span><br>			<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> Clean record <span class="hljs-variable">$sub_dm</span>.<span class="hljs-variable">$main_dm</span>: <span class="hljs-variable">$rr</span>"</span><br>			del_record <span class="hljs-variable">$rr</span> &gt;/dev/null<br>			timestamp=$(date -u <span class="hljs-string">"+%Y-%m-%dT%H%%3A%M%%3A%SZ"</span>)<br>		<span class="hljs-keyword">done</span><br>		rrid=<span class="hljs-string">''</span><br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$rrid</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		rrid=`query_recordidv6 | get_recordid`<br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$rrid</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		rrid=`add_recordv6 | get_recordid2`<br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> ADD record <span class="hljs-variable">$rrid</span>"</span><br>	<span class="hljs-keyword">else</span><br>		update_recordv6 <span class="hljs-variable">$rrid</span> &gt;/dev/null 2&gt;&amp;1<br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> UPDATE record <span class="hljs-variable">$rrid</span>"</span><br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$rrid</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>		<span class="hljs-comment"># failed</span><br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> # ERROR, Please Check Config/Time"</span><br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-comment"># save rrid</span><br>		uci <span class="hljs-built_in">set</span> tencentddns.base.record_id=<span class="hljs-variable">$rrid</span><br>		uci commit tencentddns<br>		<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$DATE</span> # UPDATED(<span class="hljs-variable">$ip</span>)"</span><br>	<span class="hljs-keyword">fi</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>IPv6地址的获取和IPv4有些不同，IPv4由于资源有限，运营商分配地址时，一个拨号用户只能分配一个32位的IP地址，例如<code>114.114.114.114</code>这样的地址，然后路由器再建立一个子网，给每个接入的设备分配一个<code>192.168.1.123</code>这样的内网地址；对于IPv6，你也可以获得一个这样完整的128位地址，不过与IPv4不同的是，IPv6由于地址数量非常多，永远不怕资源耗尽，所能可劲造。拨号连接建立之后，你不仅拿到了一个128位地址，运营商还直接分了一个IPv6网段给你，所以你在路由器上能看到一个叫做<code>分发前缀</code>的东西，一般是60位的，某些运营商分配的地址是56位的，不管是56还是60，你都获得了数不尽的IP地址，而且这些地址全部都是公网地址，有IPv6接入的互联网设备全都可以通过IP地址直接访问这些设备。</p>
<p>路由器拿到前缀之后，会按照设定的后缀（默认是<code>::1</code>）与前缀组合，给自己分配一个IPv6地址，然后再根据DHCP规则给接入路由器的其他网络设备分配地址。从<code>lan</code>口获得IPv6地址的好处就是能一并获得前缀，结合DDNS和地址静态分配，可以很方便的访问到家里某个特定的网络设备。</p>
<p>在上面的文件中增加一个变量，用于记录用户是否选择了更新IPv6的选项：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">update_ipv6=$(uci_get_by_name  base ipv6)<br></code></pre></td></tr></tbody></table></figure>

<p>最底下获取IP地址的那一段里，加一个判断语句，如果选了IPv6，就获取v6地址：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">if</span> [ <span class="hljs-string">"Z<span class="hljs-variable">$iface</span>"</span> == <span class="hljs-string">"Zinternet"</span> -o <span class="hljs-string">"Z<span class="hljs-variable">$iface</span>"</span> == <span class="hljs-string">"Z"</span> ]; <span class="hljs-keyword">then</span><br>	ip=$(intelnetip)<br><span class="hljs-keyword">else</span><br>	<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$update_ipv6</span> == 1 ]; <span class="hljs-keyword">then</span><br>		ip=$(ubus call network.interface.<span class="hljs-variable">$iface</span> status | grep <span class="hljs-string">'"address"'</span> | grep -oE <span class="hljs-string">'[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}:[0-z]{1,4}::[1]'</span> | head -1)<br>	<span class="hljs-keyword">else</span><br>		ip=$(ubus call network.interface.<span class="hljs-variable">$iface</span> status | grep <span class="hljs-string">'"address"'</span> | grep -oE <span class="hljs-string">'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'</span> | head -1)<br>	<span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></tbody></table></figure>

<p>最后执行的语句也加个判断：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$update_ipv6</span> == 1 ]; <span class="hljs-keyword">then</span><br>	check_tencentddnsv6 || do_ddns_recordv6<br><span class="hljs-keyword">else</span><br>	check_tencentddns || do_ddns_record<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></tbody></table></figure>

<p>修改一下<code>Makefile</code>更新一下版本号就大功告成了。编译完成后，安装新生成的ipk包，就能实现更新腾讯云DDNS的IPv6地址了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>使用ffmpeg为视频嵌入字幕</title>
    <url>/sui-bi/shi-yong-ffmpeg-wei-shi-pin-qian-ru-zi-mu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个轻度电影收藏爱好者，看过的电影都会丢到硬盘里放着，但是网络上有些电影资源并没有内嵌字幕，还需要外挂一个字幕，但是这样在保存的时候就需要保存两个文件，就令我很不爽，好在可以使用ffmpeg将字幕嵌入到视频文件中。</p>
<p>现在的大多电影都使用mkv格式，也有部分使用mp4，mkv格式本身支持字幕轨道，而mp4则需要调用mov_text编码器，在ffmpeg中可以很方便的将字幕和视频进行整合：</p>
<p>在我的硬盘内有一个名为<code>movie.mkv</code>的电影文件和一个名为<code>sub.srt</code>的字幕文件，在终端输入如下命令：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -i movie.mkv -i sub.srt -c:s copy -c:v copy -c:a copy output.mkv<br></code></pre></td></tr></tbody></table></figure>

<p>等待程序运行完成后，得到了一个名为<code>output.mkv</code>的视频文件，打开播放后，并没有出现字幕，但是在播放器里可以看到一个字幕流，于是我使用ffprobe检查了这两个视频文件：</p>
<p>movie.mkv:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">MycBook:Downloads simon$ ffprobe moive.mkv<br>Input <span class="hljs-comment">#0, matroska,webm, from 'movie.mkv':</span><br>...<br>...<br>    Stream <span class="hljs-comment">#0:0(eng): Video: h264 (High), yuv420p(progressive), 1920x1040, SAR 1:1 DAR 24:13, 23.98 fps, 23.98 tbr, 1k tbn, 47.95 tbc (default)</span><br>    Stream <span class="hljs-comment">#0:1(fre): Audio: dts (DTS), 48000 Hz, 5.1(side), fltp, 1536 kb/s (default)</span><br>    Metadata:<br>      title           : DTS 5.1<br>    Stream <span class="hljs-comment">#0:2(fre): Subtitle: subrip (default) (forced)</span><br>    Metadata:<br>      title           : Forced<br></code></pre></td></tr></tbody></table></figure>

<p>output.mkv:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">MycBook:Downloads simon$ ffprobe output.mkv<br>Input <span class="hljs-comment">#0, matroska,webm, from 'output.mkv':</span><br>...<br>...<br>    Stream <span class="hljs-comment">#0:1(fre): Audio: dts (DTS), 48000 Hz, 5.1(side), fltp, 1536 kb/s (default)</span><br>    Metadata:<br>      title           : DTS 5.1<br>      DURATION        : 01:33:20.681000000<br>    Stream <span class="hljs-comment">#0:2(fre): Subtitle: subrip (default) (forced)</span><br>    Metadata:<br>      title           : Forced<br>      DURATION        : 00:10:53.068000000<br></code></pre></td></tr></tbody></table></figure>

<p>原来是原来的视频有一个诡异的字幕流，只有10分钟，显然我在让ffmpeg自动选择时，程序自动选择了原视频中的字幕流，而我的字幕文件根本没有被加载。找到了问题，那就手动指定要抽取的字幕流好了，这时就需要用到<code>-map</code>参数：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -i movie.mkv -i sub.srt -map 0:v -map 0:a -map 1:s -c copy output.mkv <br></code></pre></td></tr></tbody></table></figure>

<p>其中<code>movie.mkv</code>的编号为<code>#0</code>，<code>sub.srt</code>的是<code>#1</code>，<code>v</code>代表视频流，<code>a</code>代表音频流，<code>s</code>则代表字幕流，程序会从<code>#0</code>中抽取视频流和音频流、从<code>#1</code>中抽取字幕流，复制到<code>output.mkv</code>中。<br>另外，最后的<code>copy</code>参数一定要加上，否则ffmpeg会对音视频流进行重新编码，将极大增加处理时间。</p>
<p>但是这时问题又出现了，在运行上述命令后，程序出现报错：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">sub.srt: Invalid data found when processing input<br></code></pre></td></tr></tbody></table></figure>

<p>使用less命令查看srt文件，原来是缺了一行，好在ffmpeg可以对字幕进行修复，执行命令：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -fix_sub_duration -i sub.srt sub2.srt<br></code></pre></td></tr></tbody></table></figure>

<p>所有文件准备妥当，再重新进行合并，得到的output文件成功嵌入了字幕文件！</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh">ffmpeg -i movie.mkv -i sub2.srt -map 0:v -map 0:a -map 1:s -c copy output.mkv <br></code></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>记《白鹿原》之白灵</title>
    <url>/sui-bi/ji-bai-lu-yuan-zhi-bai-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><em>白灵的眼晴有一缕傲气，却不像父也不像兄那样外露，而是作为聪意灵秀的底气支撑主宰着那双眸子，于是就和单纯的美女或一切俗气的女人显示出差异来。</em><br><em>这种眼睛首先给人一种厉害的感觉，有某种天然的凛凛傲气；这种傲气对于统帅，对于武将，乃至对于一家之主的家长来说是宝贵的难得的，而对于任何阶层的女人来说，就未必是吉祥了。</em></p>
</blockquote>
<p>——<strong>白灵的命运似乎自朱先生琢磨起她的眼睛起就已经注定。</strong></p>
<p>这段时间得空在家，终于能把几年前买下放在书架上吃灰的《白鹿原》读完。书中人物鲜明的个性给我留下了深刻的印象，我最喜欢的角色当属白嘉轩的第四个孩子——白灵。《白鹿原》故事时空里死了的人不少，却只有白灵、兆海和兆谦的死让我难以接受，及至后来读到白灵具体的死因时，更是难过地不忍卒读。</p>
<p>白灵是吴氏仙草生下的第八胎，哥哥孝义之前的三男一女悉数夭折，已经有了三个儿子的白嘉轩和妻子白吴氏正想要个女儿，于是对这个有幸活下来的孩子倍加宠爱。灵灵实在太招人喜爱，细嫩的皮肤，聪明稚气的两只忽闪水灵的大眼，胖乎乎的手腕，即便是族长白嘉轩那顽固的封建脑袋，也不免在面对灵灵时违背封建宗法，不仅亲自拆掉了灵灵的缠脚布，更是在灵灵的撒娇下答应让她去上学。彼时的中国虽然已经经历了辛亥革命，但在白鹿原上主导着社会运行的依然是封建的那一套东西，对于女子而言，上学实在是对”女子无才便是德“的极大不敬，白嘉轩虽犯了难，但还是无法对灵灵冷下脸来。</p>
<p>说来灵灵能够上学也不完全是凭她惹人疼爱的脸蛋儿。灵灵过百日时正是西安城“反正”的日子，白嘉轩为女儿灵灵满月所举行的庆贺仪式相当隆重，热烈欢悦的喜庆气氛与头生儿子的满月不相上下，亲戚朋友和乡党纷纷送来礼品与祝福，唯独少了被困在城里的冷先生。回来后，冷先生向白嘉轩讲述了城里发生的事情；加上后来听了圣人朱先生孤身一人劝退二十万清军的事迹和看到二姐的两个女儿都在城里上新式学校，白嘉轩对封建礼教的执念有所放松，虽然还穿着长袍，却把自己的头发剪掉了。女子上学在白鹿村的村民看来还是一件稀罕事，白嘉轩拉着灵灵走进白鹿村私塾的时候，村民在街巷中站成两排围观，而这种情景对于白灵来说，既新奇又十分得意的事。</p>
<p>白灵过人的聪敏和智慧此时方才慢慢显现出来，与天生就是庄稼汉的三哥孝义形成鲜明的对比。仅是写字这一件事，就让老师徐先生大为惊叹，白灵只照着徐先生起下的影格描摹半年，便可以临帖练字；两年之后，白灵的字已经在徐先生之上，徐先生发现这是个人才，赶忙让白嘉轩送她到朱先生的白鹿书院去学习。这年新年前夕，白灵写的对联被白嘉轩贴在街门的门框上，白嘉轩细细品味着，感叹根本不像一个女子的字迹。这就是白灵，字如其人，刚硬中透露出柔韧，一股豪放不羁的潇洒气度由内而外散发出来。</p>
<p>年过完后，白灵向父亲提出要去城里念书，而这一次，白嘉轩没有再一次惯着她，他冷下脸来，对白灵说出了那些封建社会女子操守，让白灵跟着母亲学做针线活。性情耿直的白灵一听父亲改变了送她去念书的主意，哇地一声哭了出来，白嘉轩不仅没有安慰，反而更加铁青着脸对白灵说：“要哭你就扯开哭”。白灵的反叛精神从此显露出来，她赌气似的收了声，坐在纺车下摇起手柄来。十天后，白灵自己跑到城里去找了二姑，没问过父亲便在城里开始上学了。白嘉轩找到二姐家时，白灵拿着一把剪刀以死相威胁。白嘉轩没有说话，回到了原上，心里百般不是滋味，白灵似乎已经成了与他有着生死之仇的敌人。</p>
<p>后来白灵抗婚逃婚的行为让我对这个女人的好感更上一层，她不仅是在与自己的命运抗衡，更是在挑战封建社会运行了千年的伦理纲常。这种不屈不挠的反抗精神对于一个革命者、一个共产党员、一个当时的女性而言是十分可贵的。越是读着对白灵的描写，我就越喜爱这个角色，她俊俏、活泼、勇敢又不失聪慧，敢爱敢恨、有理想又有抱负，及至后来得知建国后，共产党的干部带着“革命烈士”的牌子走进白嘉轩的宅院，我的心情一度十分沉重，再后来了解到白灵经历的被软禁、被关押又被活埋的过程时，更是难过地不忍卒读。一个革命者没有死在革命的道路上，没有死在敌人的利刃下，却死在了自己同志的手里，这让我无论如何也无法释怀。兆海和兆谦的死也一度让我心绪烦乱，却远无法与白灵相比较。</p>
<p>同样是与命运抗争的女子，黑娃媳妇小娥就显得无力多了，芒儿师傅的大女儿小翠则更是难以望其项背。田小娥的表面上看起来是一个不守妇道的和人乱搞的女子，但我看到的却是封建制度对女性的戕害。小娥的父亲是秀才，在当时的社会，穷苦人家中有个科举考试及第者，家庭的命运便可以彻底改变，小娥在书香门第中成长，自然是不会像一般穷人家的孩子一样，她举止优雅、穿着得体还知礼数，黑娃引着她会到家中时，鹿三一眼就看出这不是穷苦人家的女子，当即断定这不是儿子能伺候得起的人；后来孝文在小娥的窑洞里与她快活的时候也将小娥与自己的媳妇暗暗比较起来，不由地对家里那个女人产生了唾弃。按照门当户对的传统，小娥本可以拥有一段不错的后半生的，可是却被嫁到了郭举人家中当小妾，只是因为郭举人想要吃“泡枣儿”。小娥从没体验过正经的夫妻生活，有的只是郭举人每月三次在她房里例行公事般的逍遥。小娥甘愿过这样的日子吗，当然不，可是没有像白灵一样接受过新式教育的她除了能把枣儿泡在尿里之外还能做什么呢？写到这里，我倒开始同情冷先生的大女儿了……</p>
<p>白灵与兆海是在城里搬运尸体时偶然碰见的，两人对视了好久才认出是白鹿原上的乡党。那时两人是一起工作的革命同志，兆海还设法让白灵转到了他所在的学校，逐渐地，在密切的来往中，他们的关系逐渐变得不一般了起来，一种无法言说的心绪在他们心头萦绕着。终于有一天，兆海捅破了窗户纸，朝白灵吻了下去，两人私定了终身。彼时的国共合作还正有条不紊地进行着，白灵和兆海商量决定一人加入一个党，即使哪一天两党不再交好，他们也一定会继续合作，就像国与共合作一样，这誓言成了他们爱情的象征。兆海率先加入了共产党，而按照约定，白灵则要加入国民党，不过，白灵倒没有立刻入党，这也给后来他们两人婚恋的裂变埋下了伏笔。</p>
<p>后来，立志做一名真正的军人推进国民革命的兆海去了保定陆军学校学习军事，之后不久蒋介石发动了反革命政变，国共合作全面破裂，兆海退出了共产党加入了国民党。白灵那时也还没有加入任何一个党，兆海决定加入国民党的原因究竟是不是害怕再也无法和白灵像往常一样见面呢？白灵那时正在教会女子学校上课，她看见国民党的警察冲进教室将加入共产党的女学生绑走时第一个想到的就是兆海，“他能挣脱五花大绑的麻绳吗”？白灵或许就是从看到学生被填了枯井时起开始改变主意的，她急切地想找到兆鹏打听消息，见到兆鹏后，她向兆鹏述说了自己想要加入共产党的意愿。</p>
<blockquote>
<p><em>“兆海哥！人想你都想死了……”</em><br><em>“我等着你的好消息啊兆海哥……”</em><br><em>“兆海哥……我还是等着你回来……”</em></p>
</blockquote>
<p>兆海从陆军学校学习回来后，立刻找到了白灵，白灵也难以掩饰再次见到兆海的喜悦。两人漫步在承载着他们记忆的小巷里，白灵激动地告诉兆海她也像他一样加入共产党了，然而她等到的不是与她同样激动地兆海，而是兆海已经加入国民党的消息。两个怀揣着解放中华民族的理想的苦恋的人陷入了争执，接着又失语，低头看着脚下的土地……她和他在热切的期待中突然发觉对方已不是记忆中的那个人，双方都窝了兴致，都陷入痛苦。兆海出征的前天，来到了皮匠铺子，这一次依然谁都没有说服谁，可白灵怎么甘愿就这样放弃面前这个小伙子呢？她噙着泪，“兆海哥……我还是等着你回来……”</p>
<p>一段时间后，兆海的十七师撤回来了，白灵在豆腐巷小学校接待了鹿兆海。她瞅见他一身下级军官服装就觉得他们的关系将要完结了。鹿兆海在她心目中急遽地暗淡下去。兆海的理想和抱负曾经唤起她的毫无保留的赞同，可是，当初那种国民革命变得不再是驱逐封建军阀而是屠杀人民的时候，鹿兆海的抱负和志向就令她不仅是惋惜了。</p>
<p>此后直到牺牲的那一刻，白灵都一直以一个共产党员的角色投身国民革命。当日本侵略者的铁骑踏到中华大地上那会，她省立师范学校的学生自治会主席，正在筹备建立一个大中学校抗日救国统一指挥机构。白灵怀上了鹿兆鹏的孩子，她与他自然地交融在一起，他隐藏在心底的那一缕歉意的畏缩已以灼干散尽。在一次对民国教育部陶部长的示威中，白灵失手将砖头丢在了陶部长的脸上，她的身份随之暴露，被迫开始转移。在几百里外的龙湾村，她生下了这个叫鹿鸣的孩子。</p>
<p>白嘉轩的噩梦不幸被朱先生绝妙而诡秘的掐算言中，白灵在南梁根据地走向了她生命的尽头。</p>
<p>白灵辗转在地下党的护送下，被转运到了南梁根据地，随后就被安排做文化教员。在根据地，她出色的工作和活泼开朗的性格使她得到上至廖军长下至小队长的表彰，也得到游击队员们的拥戴。她给游击队员教字学文化，也帮他们缝补撕裂磨损的衣裤鞋袜，听队员们给她唱山歌，她把那些悠扬哀婉的山歌改换唱词变成革命歌曲，朗朗上口的歌词很快在队伍中流传开来。越是看着白灵那活泼的样子，就越是让我难受，这么好的一个女子没有等来革命胜利的那一天，没有看到自己的努力汇进人民战争的洪流入海，就永远倒下了。廖军长气急骂了毕政委，也被毕政委关起来了，白灵的保护伞就此消失，她被关押的时候，那百灵鸟一般的嗓子连着嗥了三天三夜，她的嗓子依然宏亮，精神依旧亢奋，双眼仍然如炬。终于等来了毕政委，她把所有的激情都释放出来，像一头拼死的母狮咆哮起来，她把生命中最后一丝顽强全部展现出来，砖头一样的话拍击着毕政委——就像她扔向陶部长的那块砖头一样。</p>
<p>然而在白灵被活埋完毕后，我的心情却没有之前那么低落了，这个革命者完成了她的最后一次挣扎，虽然没有被填枯井，但就像成千上万为革命牺牲的人民一样，他们的精魄铸就了中华民族之魂。她的死亡细节已经不再重要——正如鹿鸣所说——重要的是对发生这一幕历史悲剧的根源的反省。</p>
<p>兆海也在中条山牺牲了，他曾对白灵说非她终身不娶，可后来在金关城买下一栋民房，与当地一位女子成婚了。兆海违背了他的誓言吗？这个神似灵灵的女子不过是他对她日夜思念的寄托罢了……</p>
<p>苦命的恋人啊……</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
